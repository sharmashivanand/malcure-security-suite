<?php
class MI_Malware_Scanner extends MI_Scanner {

	static function get_instance() {
		static $instance = null;
		if ( is_null( $instance ) ) {
			$instance = new self();
			$instance->init();
		}
		return $instance;
	}

	private function __construct() {
	}

	function init() {
		add_action( 'wp_ajax_nsmi_trigger_scan', array( $this, 'trigger_scan' ) );
		add_action( 'wp_ajax_nopriv_nsmi_trigger_scan', 'trigger_scan' );
		add_action( 'wp_ajax_nsmi_init_scan', array( $this, 'init_scan_handler' ) );
		add_action( 'wp_ajax_nopriv_nsmi_init_scan', array( $this, 'init_scan_handler' ) );
		add_action( 'wp_ajax_nsmi_scan_request', array( $this, 'scan_responder' ) );
		add_action( 'wp_ajax_nopriv_nsmi_scan_request', array( $this, 'scan_responder' ) );
		add_action( 'wp_ajax_nsmi_scan_status', array( $this, 'scan_status_handler' ) );
		add_action( 'wp_ajax_nopriv_nsmi_scan_status', '__return_false' );
		add_action( 'upgrader_process_complete', array( $this, 'delete_checksums' ), 9999, 2 );
		add_action( 'MI_security_suite_add_meta_boxes', array( $this, 'add_meta_boxes' ), 8 );
		// add_action( 'wp', array( $this, 'trigger_maintenance' ) );
	}

	function trigger_maintenance() {
		// nsmi_utils::do_maintenance();
	}

	function options_debug( $option, $old_value, $value ) {
		if ( $option == 'NSMI' ) {
			if ( empty( $value['scan'] ) ) {
				return;
			} else {
			}
		}
	}

	function delete_checksums() {
		nsmi_utils::delete_option_checksums_core();
	}

	function add_meta_boxes() {
		add_meta_box( 'nsmi_scanner', 'Malware Scanner', array( $this, 'scanner_meta_box' ), $GLOBALS['MI_security_suite']['pagehook'], 'main' );
	}

	function update_definitions() {
		if ( nsmi_utils::is_registered() ) {
			nsmi_utils::update_definitions();
			return true;
		}
	}

	function scanner_meta_box() {
		$running = $this->is_scan_running();
		if ( $running ) {
			$attrib = 'disabled="disabled"';
			$ui     = 'Scan already running';
		} else {
			$attrib = '';
			$ui     = 'Scan';
		}
		
		echo '<input class="nsmi_action" value="'.$ui.'" id="nsmi_scan_btn" type="submit" '.$attrib.'/>';
		// nsmi_utils::llog( nsmi_utils::get_setting( 'log' ) );
		// nsmi_utils::delete_setting( 'log' );
		// nsmi_utils::delete_setting( 'scan_id' );
		// nsmi_utils::delete_setting( 'scan_progress' );
			// nsmi_utils::do_maintenance();
		nsmi_utils::fetch_theme_checksums();
		echo '<div id="scan_status"><div id="scan_completion"></div></div>';
		echo '<div id="scan_results"></div>';
		?>
		<script type="text/javascript">
			jQuery(document).ready(function($){
				$("#nsmi_scan_btn").click(function(){
					nsmi_trigger_scan = {
						nsmi_trigger_scan_nonce: '<?php echo wp_create_nonce( 'nsmi_trigger_scan' ); ?>',
						action: "nsmi_trigger_scan",
					};
					$.ajax({
						url: ajaxurl,
						method: 'POST',
						data: nsmi_trigger_scan,
						success: function(data, textStatus, jqXHR) {
							console.dir('success Data Begins');
							console.dir(data);
							console.dir(textStatus);
							console.dir(jqXHR);
							console.dir('success Data Ends');
							nsmi_status_updater = setTimeout(nsmi_update_scan_status,1000);
							if ((typeof data) != 'object') {
							}
							if (data.hasOwnProperty('success')) {
							} else {
							}
						},
						error: function( jqXHR, textStatus, errorThrown){},
						complete: function(jqXHR_data, textStatus) {},
					});
				});
				nsmi_status_updater = setTimeout(nsmi_update_scan_status,1000);
			});

			function nsmi_update_scan_status() {
				var $ = jQuery.noConflict();
				nsmi_scan_status = {
					nsmi_scan_status_nonce: '<?php echo wp_create_nonce( 'nsmi_scan_status' ); ?>',
					action: "nsmi_scan_status",
				};
				$.ajax({
					url: ajaxurl,
					method: 'POST',
					data: nsmi_scan_status,
					success: function (data, textStatus, jqXHR) {
						console.dir(data);
						// received ajax response successfully (could be an wp_send_json error or success = both)
						if (data.success) {
							if (data.data) {
								$('#scan_status').addClass('inprogress');
								if (data.data.total) {
									console.dir(data.data.total);
									console.log('found total:' + data.data.total);
									remaining = parseInt(data.data.remaining);
									total = parseInt(data.data.total);
									done = total - remaining;
									per = (done / total) * 100;
									per_done = per;
									started = parseInt(data.data.started);
									now = parseInt(data.data.now);
									secs = now - started;
									console.log(per_done.toFixed(1) + '% ' + done + '/' + data.data.total + ' @ ' +  done / secs + ' Files / Sec');
									//$('#scan_status').css('background', '#36717d linear-gradient(90deg, hsla(175, 100%, 75%, 1) 0%, hsla(175, 100%, 75%, 1) ' + per_done + '%, transparent ' + per_done + '%, transparent )');
									$('#scan_completion').css('background', 'hsl(200, 40%, 35%) linear-gradient(90deg, hsla(175, 100%, 75%, 1) 0%, hsla(175, 100%, 75%, 1) ' + per_done + '%, transparent ' + per_done + '%, transparent )');
									// $('#scan_status').html(Number.parseFloat(per_done).toFixed(2) + '%');
									$('#scan_completion').html('<span id="text_percentage">' + Number.parseFloat(per_done).toFixed(2) + '%</span>');
								}
								if (data.data.results && (data.data.results.files || data.data.results.db)) {
									if (data.data.results.files) {
										files = data.data.results.files;
										//console.dir(files);
										//$results = '<table>';
										$results = '';
										for (const [key, value] of Object.entries(files)) {
											//console.dir(value);
											$results += `<div class="result result_file ${value.severity}"><span class="threat sig ${value.severity}">${value.id}</span><span class="file">${key}</span></div>`;
											// $results += `<tr><td><span class="sig threat ${value.severity}"><span class="sig">${value.id}</span><span class="file">${key}</span></span></td></tr>`;
										}
										//$results += '</table>';
										$('#scan_results').html($results);
									}
								}
								try{
									if(remaining) {
										nsmi_status_updater = setTimeout(nsmi_update_scan_status, 1000);
									}
								}
								catch(e){
									console.dir(jqXHR.responseJSON.data);
									console.dir(jqXHR.responseJSON.data.remaining);
								}
							}
						} else {
							console.log('Updater got failure.');
						}
						if ((typeof data) != 'object') {}
						if (data.hasOwnProperty('success')) {} else {}
					},
					error: function (jqXHR, textStatus, errorThrown) {
						console.dir('eberror: updater error Data Begins');
						console.dir(jqXHR);
						console.dir(textStatus);
						console.dir(errorThrown);
						console.dir('cberror: updater error Data Ends');
					},
					complete: function (jqXHR_data, textStatus) {
					},
				});
			}
		</script>

		<div style="background: #bd284188; color: white; padding: 1.618em 1em; font-weight:bold">
			<style type="text/css">
			strike {
				opacity: .5;
			}
			</style>
			<h3 style="color:white;">Pre-Release Checklist</h3>
			<ol>
				<li>Status Update Handler client-side: Handle wp_send_json_error cases in status updater client side.</li>
				<li>Updater should only run if scan is running. Else just display the results.</li>
				<li>Allow user to clear a stuck scan. Or automatically clear it?</li>
				<li>Implement do_maintenance automation.</li>
				<li>Implement database scan.</li>
				<li>Update Branding to Malware Intercept. Can call it MI Security Suite.</li>
				<li>Implement license.</li>
				<li>Cron scan should limit itself to files under the root, wp-admin, wp-content and wp-includes.</li>
				<li>Should we use CPU stats for throttling? Isn't the response time indicative of the throttling required?</li>
				<li>Cron should report excluded files.</li>
				<li>Assess use fo recursive-iterator for filtering / excluding files. If files are excluded, how to verify they are safe? Implement array_udiff_assoc etc. to catch files that failed checksums.</li>
			</ol>
			<ol>
				<li><strike>Cancel scan if first batch fails</strike></li>
				<li><strike>Implement Cancel Scan and Disable do_maintenance self::delete_setting( 'scan_id' ); self::delete_setting( 'scan_progress' ); before release.</strike></li>
				<li><strike>No duplication of online checksums.</strike></li>
				<li><strike>Wrong: Instead of deleting the progress tracker, just set the remaining count to 0. This will ensure that the UI shows the progress of the previous scan and can update upon initiating a new scan.</strike></li>
				<li><strike>Redundant: Status updater should only run if a scan is in progress, else it should fetch the results of the last scan and quit.</strike></li>
				<li><strike>Use registration screen should prompt for api account registration without which the plugin shouldn't work. Readme should clearly say... This plugin allows to integrate your WordPress website with MI Security Suite and uptime monitoring service. This is a SaaS service. Api access is free for fair use as of now. As our user base and traffic load grows, we continue to refine access limits.</strike></li>
				<li><strike>mss: scan button should be disabled if a scan is already running</strike></li>
				<li><strike>Move file scan function to it's own so that it can be called n number of times to scan failed files / at least thrice.</strike></li>
				<li><strike>Implement prioritizing sever, hign and suspicious definitions.</strike></li>
				<li><strike>Implement fetching theme checksums.</strike></li>
				<li><strike>md5_file throws a warning in case of unreadable file. need to fix in mss and wpmr</strike></li>
				<li><strike>Open registration form if user is not registered.</strike></li>
				<li><strike>updated NSMI files are not reported in failed checksums? (Nope they should show as extra files if we don't have checksum for that specific version.)</strike></li>
				<li><strike>test definition update for unregistered user. Yep: echo nsmi_utils::get_api_url( 'update-definitions' ); https://wp-malware-removal.com/?cachebust=1624292997&wpmr_action=update-definitions&state=eyJXQyByZXF1aXJlcyBhdCBsZWFzdCI6IiIsIldDIHRlc3RlZCB1cCB0byI6IiIsIldvbyI6IiIsIk5hbWUiOiJtYWxDdXJlIFNlY3VyaXR5IFN1aXRlIiwiUGx1Z2luVVJJIjoiaHR0cHM6XC9cL21hbGN1cmUuY29tXC8iLCJWZXJzaW9uIjoiMC41IiwiRGVzY3JpcHRpb24iOiJtYWxDdXJpdHkgU2VjdXJpdHkgU3VpdGUgaGVscHMgeW91IGxvY2sgZG93biBhbmQgc2VjdXJlIHlvdXIgV29yZFByZXNzIHNpdGUuIiwiQXV0aG9yIjoibWFsQ3VyZSIsIkF1dGhvclVSSSI6Imh0dHBzOlwvXC9tYWxjdXJlLmNvbSIsIlRleHREb21haW4iOiJtYWxjdXJlLXNlY3VyaXR5LXN1aXRlIiwiRG9tYWluUGF0aCI6IiIsIk5ldHdvcmsiOmZhbHNlLCJSZXF1aXJlc1dQIjoiIiwiUmVxdWlyZXNQSFAiOiIiLCJUaXRsZSI6Im1hbEN1cmUgU2VjdXJpdHkgU3VpdGUiLCJBdXRob3JOYW1lIjoibWFsQ3VyZSJ9</strike></li>
			</ol>
		</div>

		<?php
	}

	/**
	 * Init Scan
	 */
	function trigger_scan() {
		if ( ! wp_doing_ajax() && ! wp_doing_cron() ) {
			wp_die();
		}
		if ( wp_doing_ajax() ) {
			check_ajax_referer( 'nsmi_trigger_scan', 'nsmi_trigger_scan_nonce' );
			if ( ! current_user_can( nsmi_utils::$cap ) ) {
				wp_die();
			}
		}
		// nsmi_utils::do_maintenance();
		$already_running = $this->is_scan_running(); // nsmi_utils::get_setting( 'scan_id' );
		if ( $already_running ) {
			nsmi_utils::append_log( __FUNCTION__ . ': ERROR: Scan ID ' . $already_running . ' is already running' );
			wp_send_json_error( 'ERROR: Scan ID ' . $already_running . ' is already running' );
		}
		// Test scannability here
		$scan_id = time();
		nsmi_utils::update_setting( 'scan_id', $scan_id );
		$args     = array(
			'blocking' => false,
			'timeout'  => 0.01,
			'body'     => array(
				'action'        => 'nsmi_init_scan',
				'handshake_key' => wp_hash_password( $scan_id ),
			),
		);
		$response = wp_remote_post(
			admin_url( 'admin-ajax.php' ),
			$args
		);
		wp_send_json_success( $scan_id );
	}

	/**
	 * Step 2: Processes a full file + DB scan over remote requests
	 */
	function init_scan_handler() {
		$start_time = microtime( true );
		$scan_id    = nsmi_utils::get_setting( 'scan_id' );
		if ( empty( $scan_id ) || empty( $_REQUEST['handshake_key'] ) || ! wp_check_password( $scan_id, $_REQUEST['handshake_key'] ) ) {
			wp_die();
		}
		$result  = $this->update_definitions();
		$success = $this->file_scan( $scan_id );
		if ( $success ) {
			$success = $this->db_scan( $scan_id );
		} else {
			nsmi_utils::append_log( __FUNCTION__ . ': File_scan retuned failure. Skipping database scan' );
		}
		nsmi_utils::delete_setting( 'scan_id' ); // always delete scan_id and allow user to attempt another scan
		// nsmi_utils::update_setting( 'scan_id', $scan_id );
	}

	function file_scan( $scan_id ) {
		$cores   = nsmi_utils::num_cpus();
		$timeout = ini_get( 'max_execution_time' );
		if ( empty( $timeout ) ) {
			$timeout = 29;
		} else {
			$timeout = $timeout - 1;
		}
		$start_time = microtime( true );
		$checksums  = $this->get_checksums();
		$files      = nsmi_utils::get_files();
		if ( ! empty( $files['files'] ) ) {
			$files = $files['files'];
			$total = count( $files );
			nsmi_utils::update_setting(
				'scan_progress',
				array(
					'total'     => $total,
					'remaining' => $total,
				)
			);
		} else {
			nsmi_utils::append_log( __FUNCTION__ . ': Scanner could not generate a list of files.' );
			// nsmi_utils::flog( __FUNCTION__ . ':' . __LINE__ . 'Scanner could not generate a list of files.' );
			throw new Exception( 'Scanner could not generate a list of files.' );
		}
		// nsmi_utils::update_setting( 'scan_id', $scan_id );
		$site_url    = admin_url( 'admin-ajax.php' );
		$host        = parse_url( $site_url, PHP_URL_HOST );
		$local_url   = str_replace( $host, 'localhost', $site_url );
		$failed      = array();
		$batch_size  = 11;
		$perf        = array();
		$segments    = 3;
		$files_done  = 0;
		$wait        = 0;
		$test_passed = -1;
		while ( $files ) {
			set_time_limit( $timeout );
			if ( count( $perf ) >= $segments ) {
				$perf            = array_splice( $perf, count( $perf ) - $segments, $segments );
				$time_factor     = ( $timeout / 2 ) - $time_taken;
				$time_factor_per = ( $time_factor * 100 ) / ( $timeout / 2 );
				$polarity        = ( ( min( $perf ) < 0 ) || $time_factor < 0 ) ? -1 : 1;
				$factor          = abs( $time_factor_per / ( abs( array_sum( $perf ) ) / 2 ) );
				$boost           = ( $polarity * ( ( $batch_size * $factor ) / 100 ) );
				$batch_size      = round( $batch_size + $boost );
				$batch_size      = min( $batch_size, 111 );
				// $cpu             = @sys_getloadavg(); // will return NULL if this function is disabled
				// if ( $cores && ! is_null( $cpu ) && ( ( $cpu[0] / $cores ) > 1.11 ) ) {
				// $batch_size = round( $batch_size / $segments );
				// nsmi_utils::flog( 'Throttling to ' . $batch_size . ' due to CPU Load:' . json_encode( $cpu ) );
				// }
				$batch_size = max( $batch_size, 1 );
				if ( $batch_size == 1 ) { // if batch size continues to be 1, let's sleep 1 seconds on alternate requests
					$wait = ! $wait;
					if ( $wait ) {
						nsmi_utils::flog( 'Minimum batch size reached. Waiting for breath.' );
						sleep( 1 );
					}
				}
			}
			nsmi_utils::flog( 'Batch-size : ' . $batch_size );
			$batch              = array_splice( $files, 0, $batch_size );
			$files_done        += count( $batch );
			$ts                 = microtime( true );
			$scan_request_start = microtime( 1 );
			if ( $test_passed == -1 || $test_passed ) {
				$results = $this->make_scan_request( $batch, 'file', $_REQUEST['handshake_key'], $local_url, $host, $timeout );
			}
			// else {
			// nsmi_utils::append_log( __FUNCTION__ . ': Scan test failed. Cancelling remaining batches.' );
			// return false;
			// }
			// nsmi_utils::flog( '$results' );
			// nsmi_utils::flog( $results );
			$scan_request_end = microtime( 1 );
			$time_taken       = $scan_request_end - $scan_request_start;
			nsmi_utils::flog( 'Batch-Scan Response Time : ' . $time_taken );
			// nsmi_utils::append_log( __FUNCTION__ . ': Scan test failed. Cancelling remaining batches.' );
			if ( $results ) {
				$perf[] = 1;
				if ( $test_passed == -1 ) {
					// nsmi_utils::append_log( __FUNCTION__ . ': Scan test Passed. Proceeding with remaining batches.' );
					$test_passed = 1;
				}
			} else {
				$failed = array_merge( $failed, $batch );
				nsmi_utils::flog( __FUNCTION__ . ':' . __LINE__ . ' !!!!!! FAILED !!!!!! with result:' . $results );
				$perf[] = -1;
				if ( $test_passed == -1 ) {
					nsmi_utils::flog( 'Scan test failed.' );
					nsmi_utils::append_log( __FUNCTION__ . ': Scan test failed. Cancelling remaining batches.' );
					$test_passed = 0;
					nsmi_utils::append_log( __FUNCTION__ . ': Scan test failed. Cancelling remaining batches.' );
					return;
				}
			}
			$scan_progress = array(
				'total'     => $total,
				'remaining' => $total - $files_done,
				'rate'      => ( $files_done / ( microtime( 1 ) - $start_time ) ),
				//'scanning'		=> array('file' =>  $temp[0] . "\t RECEIVED " . count( array_values( $data ) ) . ' files.' );)
			);
			nsmi_utils::flog( '$batch' );
			nsmi_utils::flog( $batch );
			nsmi_utils::flog( '$batch[ count($batch) - 1 ]' );
			nsmi_utils::flog( $batch[ count($batch) - 1 ] );
			nsmi_utils::update_setting( 'scan_progress', $scan_progress );
			if ( ! count( $files ) ) {
				nsmi_utils::flog( 'Check value of $scan_progress since no files remaining.' );
				// nsmi_utils::delete_setting( 'scan_progress' );
			}
			$te = microtime( true );
		}
		nsmi_utils::flog( 'Failure Count: ' . count( $failed ) );
		$end_time       = microtime( true );
		$execution_time = ( $end_time - $start_time );
		nsmi_utils::flog( 'Full Scan Completion Time: ' . human_time_diff( $start_time, $end_time ) );
		nsmi_utils::flog( 'COMPLETED File Scan for SCAN ID : ' . $scan_id );
		// nsmi_utils::delete_setting( 'scan_id' );
		return $execution_time;
	}

	function db_scan( $scan_id = false ) {
		nsmi_utils::flog( __FUNCTION__ . ' Needs to be tested and implemented' );
		return;
		$start_time_db = microtime( true );
		global $wpdb;
		$scan_sqls   = array(
			'post'      => "SELECT ID AS id, post_content AS content, post_type as post_type FROM $wpdb->posts where post_content LIKE '%s'",
			'post_meta' => "SELECT post_id AS id, meta_value AS content FROM $wpdb->postmeta where meta_value LIKE '%s'",
			'option'    => "SELECT option_id AS id, option_value AS content FROM $wpdb->options WHERE option_value LIKE '%s'",
			'comment'   => "SELECT comment_ID AS id, comment_content AS content FROM $wpdb->comments WHERE comment_content LIKE '%s' AND comment_approved = '1'",
		);
		$definitions = $this->get_malware_db_definitions();
		$db_results  = array();
		$db_scan_log = array();
		if ( ! empty( $GLOBALS['WPMR']['wpmr_extra_db_query'] ) && ! empty( $GLOBALS['WPMR']['wpmr_extra_db_regex'] ) ) {
			$definitions['DWPMR'] = array(
				'severity'  => 'severe',
				'query'     => $GLOBALS['WPMR']['wpmr_extra_db_query'],
				'signature' => $GLOBALS['WPMR']['wpmr_extra_db_regex'],
			);
		};
		foreach ( $definitions as $ver => $details ) {
			foreach ( $scan_sqls as $key => $sql ) {
				$results = $wpdb->get_results( $wpdb->prepare( $sql, nsmi_utils::decode( $details['query'] ) ), ARRAY_A );
				foreach ( $results as $result ) {
					$content     = $result['content'];
					$id          = sanitize_text_field( $result['id'] );
					$post_status = empty( $result['post_type'] ) ? '' : 'post-type &rarr; ' . $result['post_type'] . '.';
					$matches     = preg_match( nsmi_utils::decode( $details['signature'] ), $content, $found );
					$pcre_err    = preg_last_error();
					if ( $pcre_err != 0 ) {
						continue;
					}
					if ( $matches >= 1 ) {
						if ( in_array( $details['severity'], array( 'severe', 'high' ) ) ) {
							nsmi_utils::update_setting( 'infected', true );
						}
						$db_results[ $id ]  = $this->set_status( $details['severity'], 'Found database infection(s) in ' . ucwords( $key ) . " id $id. $post_status Threat Level &rarr; " . $details['severity'] . '.', $ver );
						$db_scan_log[ $id ] = array(
							'severity'  => $details['severity'],
							'infection' => $ver,
							'type'      => ucwords( $key ),
							'id'        => $id,
						);
					}
				}
			}
		}
		if ( $db_results ) {
			if ( ! empty( $db_scan_log ) && ! empty( $GLOBALS['WPMR']['timestamp'] ) ) {
				$record      = $GLOBALS['WPMR']['timestamp'];
				$db_scan_log = array( 'db' => $db_scan_log );
				$db_scan_log = json_encode( $db_scan_log );
			}
			return $db_results;
		}
		$end_time_db = microtime( true );
		nsmi_utils::flog( __FUNCTION__ . ':' . __LINE__ . ' Time Taken:' . ( $end_time - $start_time ) );
		return $db_results;
	}

	function is_scan_running() {
		$scan_id_setting = nsmi_utils::get_setting( 'scan_id' );
		nsmi_utils::flog( $scan_id_setting );
		return $scan_id_setting;
		// if ( $scan_id == $scan_id_setting ) {
		// return true;
		// }
	}

	function get_failed_files( $files ) {
		$total         = count( $files );
		$scan_progress = array(
			'total'     => $total,
			'remaining' => count( $files ),
		);
		$i             = 0;
		foreach ( $files as $file ) {
			$start_time = microtime( true );
			$end_time   = microtime( true );
			set_time_limit( 1 );
			if ( $this->fails_checksum( $file ) ) {
				$failed[] = $file;
			}
			$i++;
			if ( $i % 100 == 0 ) {
				$scan_progress = array(
					'total'     => $total,
					'remaining' => $total - $i,
				);
				nsmi_utils::update_setting(
					'scan_progress',
					$scan_progress
				);
			}
			$execution_time = ( $end_time - $start_time );
		}
		return $failed;
	}

	/**
	 * Function to request a singular remote scan
	 *
	 * @param [type] $data
	 * @param [type] $type
	 * @return void
	 */
	function make_scan_request( $data, $type, $handshake_key, $local_url = '', $host = '', $timeout = 5 ) {
		nsmi_utils::flog( __FUNCTION__ . ' : ' . __LINE__ . ' making resuest type : ' . $type );
		$start_time = microtime( true );
		$args       = array(
			'timeout'     => $timeout,
			'httpversion' => '1.1',
			'body'        => array(
				'action'        => 'nsmi_scan_request',
				'data'          => $data,
				'handshake_key' => $handshake_key,
				'type'          => $type,
			),
		);
		$url        = admin_url( 'admin-ajax.php' );
		$response   = wp_remote_post( $url, $args );
		nsmi_utils::flog( wp_remote_retrieve_response_code( $response ) );
		// nsmi_utils::flog( $response );
		if ( wp_remote_retrieve_response_code( $response ) != 200 ) {
			nsmi_utils::flog( __FUNCTION__ . ':' . __LINE__ . ' failed ' );
			nsmi_utils::flog( '$url:' . $url );
			nsmi_utils::flog( '$args' );
			nsmi_utils::flog( $args );
			nsmi_utils::flog( '$response' );
			nsmi_utils::flog( $response );
			nsmi_utils::append_log( __FUNCTION__ . ': received response code ' . wp_remote_retrieve_response_code( $response ) );
			nsmi_utils::flog( 'returning null!' );
			return;
		}
		$body = wp_remote_retrieve_body( $response );
		if ( $body ) {
			$body = json_decode( $body, 1 );
			if ( is_null( $body ) ) { // invalid json
				return;
			} else { // valid json
				return true;
			}
		} else { // no body
			return;
		}
		nsmi_utils::flog( 'This should never be logged' );
		// return true;
		// $body = wp_remote_retrieve_body( $response );
		// if ( empty( $body ) || is_null( json_decode( $body ) ) ) {
		// return;
		// }
		// $results = json_decode( $body, 1 );
		// if ( ! empty( $results['success'] ) ) {
		// return $results;
		// }
		$end_time = microtime( true );
	}

	/**
	 * Final end-point, Responds to ajax scan request, scans synchronously, prone to hang
	 *
	 * @return void
	 */
	function scan_responder() {
		// nsmi_utils::flog( __FUNCTION__ . ' returning' );
		// wp_die();
		nsmi_utils::flog( __FUNCTION__ . ':' . __LINE__ . ' responding.' );
		$scan_id = nsmi_utils::get_setting( 'scan_id' );
		if ( empty( $scan_id ) || empty( $_REQUEST['handshake_key'] ) || ! wp_check_password( $scan_id, $_REQUEST['handshake_key'] ) ) {
			nsmi_utils::flog( __FUNCTION__ . ':' . __LINE__ . ' detected unauthenticated request.' );
			wp_die();
		}
		$data = $_REQUEST['data'];
		$type = $_REQUEST['type'];
		$temp = array_values( $data );
		$temp = array_splice( $temp, count( $temp ) - 1, 1 );
		nsmi_utils::flog( "\t\tSCANNING: " . $temp[0] . "\t RECEIVED " . count( array_values( $data ) ) . ' files.' );

		// nsmi_utils::flog( 'backtrack_limit ' . ini_get( 'pcre.backtrack_limit' ) );
		// nsmi_utils::flog( 'recursion_limit ' . ini_get( 'pcre.recursion_limit' ) );
		// nsmi_utils::flog( '==' );

		$backtrackLimit = ini_get( 'pcre.backtrack_limit' );
		if ( is_numeric( $backtrackLimit ) ) {
			$backtrackLimit = (int) $backtrackLimit;
			if ( $backtrackLimit > 1000000 ) {
				ini_set( 'pcre.backtrack_limit', 1000000 );
				ini_set( 'pcre.recursion_limit', 1000000 );
			}
		}
		
		if ( $type == 'file' ) {
			$files   = $data;
			$results = array();
			foreach ( $files as $file ) {
				if ( preg_match( '/\.malware/', $file ) || preg_match( '/wp\-content/', $file ) ) { // || preg_match( '/plugins/', $file ) || preg_match( '/wp\-content/', $file )
				continue;
				nsmi_utils::flog( "\t\tSKIPPING:" . $file );
				}
				if ( $this->fails_checksum( $file ) ) {
					$start = microtime( 1 );

					$scan  = $this->scan_file( $file );
					// nsmi_utils::flog( 'backtrack_limit took ' . ini_get( 'pcre.backtrack_limit' ) );
					// nsmi_utils::flog( 'recursion_limit took ' . ini_get( 'pcre.recursion_limit' ) );
					// nsmi_utils::flog( '==' );
					// nsmi_utils::flog( 'scan_file took ' . ( microtime( 1 ) - $start ) . 'sec' );
					if ( $scan ) {
						if ( ! empty( $scan['id'] ) ) {
							$results[ $file ] = $scan;
						} else {
						}
					} else {
					}
				}
			}
			$this->update_scan_status( $results, $scan_id, 'files' );
		}
		if ( ( $type == 'db' ) ) {
		}
		wp_send_json_success();
	}

	function update_scan_status( $data, $scan_id, $type ) {
		if ( ! $scan_id ) {
			die();
		}
		$scan_id = strval( $scan_id );
		$scans   = nsmi_utils::get_option( 'scans' );
		if ( empty( $scans ) ) {
			$scans = array();
		}
		if ( empty( $scans[ $scan_id ] ) ) {
			$scans[ $scan_id ] = array( $type => array() );
		}
		$scans[ $scan_id ][ $type ] = array_merge( $scans[ $scan_id ][ $type ], $data );
		nsmi_utils::update_option( 'scans', $scans );
	}

	/**
	 * Send status of the scan
	 * return total count, remaining count, (bool) complete, time to expiry
	 */
	function scan_status_handler() {
		// sleep(1000000);
		// nsmi_utils::fetch_checksums();
		$progress = nsmi_utils::get_setting( 'scan_progress' );
		$progress = array(
			'started'   => false,
			'results'   => array(),
			'total'     => $progress['total'],
			'remaining' => $progress['remaining'],
			'complete'  => 1,
			'now'       => time(),
			// 'setting' => nsmi_utils::get_setting( 'scan_progress' )
		);
		$scan_id = nsmi_utils::get_setting( 'scan_id' );
		$scan    = nsmi_utils::get_option( 'scans' );
		// scan_progress
		if ( ! $scan ) {
			wp_send_json_error( $progress );
		}
		$scan = array_slice( $scan, count( $scan ) - 1, 1, true );
		if ( ! $scan ) {
			wp_send_json_error( $progress );
		}
		$complete             = empty( $scan_id ) ? true : false;
		$progress['complete'] = $complete;
		$progress['started']  = array_keys( $scan )[0];
		$progress['results']  = array_values( $scan )[0];
		wp_send_json_success( $progress );
	}

	function submenu_page() {
		add_submenu_page(
			'_nsmi',
			'MI Malware Scanner',
			'Malware Scanner',
			NSMI_GOD,
			'scanner_nsmi',
			array( $this, 'scanner_nsmi_page' ),
			null
		);
	}

	function get_checksums() {
		return nsmi_utils::fetch_checksums();
	}

	function fails_checksum( $local_file ) {
		$start     = microtime( 1 );
		$checksums = $this->get_checksums();
		$expected  = @md5_file( $local_file );
		if ( ! $expected ) {
			// nsmi_utils::flog('checksum took ' . (microtime(1) - $start) . 'sec');
			return 1;
		}
		$match_path = nsmi_utils::normalize_path( $local_file );
		if ( array_key_exists( $match_path, $checksums ) ) {
			if ( is_array( $checksums[ $match_path ] ) ) {
				if ( ! in_array( $expected, $checksums[ $match_path ] ) ) {
					// nsmi_utils::flog('checksum took ' . (microtime(1) - $start) . 'sec');
					return 1;
				} else {
					// nsmi_utils::flog('checksum took ' . (microtime(1) - $start) . 'sec');
					return;
				}
			} else {
				if ( $checksums[ $match_path ] != $expected ) {
					// nsmi_utils::flog('checksum took ' . (microtime(1) - $start) . 'sec');
					return 1;
				} else {
					// nsmi_utils::flog('checksum took ' . (microtime(1) - $start) . 'sec');
					return;
				}
			}
		} else {
			// nsmi_utils::flog('checksum took ' . (microtime(1) - $start) . 'sec');
			return 1;
		}
	}
}

MI_Malware_Scanner::get_instance();
