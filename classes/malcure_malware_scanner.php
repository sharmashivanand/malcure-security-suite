<?php
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

define( 'MSS_SCANNERTABLE', 'mss_generated' );
define( 'MSS_CHECKSUMTABLE', 'mss_original' );
/**
 * Singleton Class for WordPress File Indexer
 */
final class Malcure_Malware_Scanner {
	private static $instance = null;
	private $state           = false;
	// private $pad                = 0;
	private $tablename          = '';
	private $max_execution_time = false;
	private $os_entry_dir       = false;
	private $time_buffer        = 2;


	public $filemaxsize = 1111111;
	// public $filemaxsize = 111;

	private function __construct() {
	}

	public static function get_instance() {
		if ( self::$instance === null ) {
			self::$instance = new self();
			self::$instance->init();
		}
		return self::$instance;
	}

	/**
	 * Initializes hooks and filters
	 *
	 * @return void
	 */
	function init() {
		// ini_set( 'max_execution_time', 5 );
		// ini_set( 'max_execution_time', 5 );
		// ini_set( 'error_log', '/var/www/html/dev/plugindev/wp/wp-content/plugins/malcure-security-suite/log.log' );

		$this->max_execution_time = ini_get( 'max_execution_time' ); // Get the max_execution_time
		$backtrackLimit           = ini_get( 'pcre.backtrack_limit' );
		if ( is_numeric( $backtrackLimit ) ) {
			$backtrackLimit = (int) $backtrackLimit;
			if ( $backtrackLimit > 1000000 ) {
				ini_set( 'pcre.backtrack_limit', 1000000 );
				ini_set( 'pcre.recursion_limit', 1000000 );
			}
		}

		$this->scannertablename  = $GLOBALS['wpdb']->prefix . MSS_SCANNERTABLE;
		$this->checksumtablename = $GLOBALS['wpdb']->prefix . MSS_CHECKSUMTABLE;

		$this->os_entry_dir = ABSPATH;

		add_action( 'Malcure_security_suite_add_meta_boxes', array( $this, 'add_meta_boxes' ), 8 );

		add_action( 'wp_ajax_nopriv_mss_scan_operation', array( $this, 'scan_operation_handler' ) );
		add_action( 'wp_ajax_mss_scan_operation', array( $this, 'scan_operation_handler' ) );

		add_action( 'wp_ajax_nopriv_mss_scan_file', array( $this, 'scan_file' ) );
		add_action( 'wp_ajax_mss_scan_file', array( $this, 'scan_file' ) );

		add_action( 'mss_plugin_activation', array( $this, 'db_install' ) );
		add_action( 'plugins_loaded', array( $this, 'upgrade_tables' ) );
	}

	/**
	 * Create the database tabled required for the plugin
	 *
	 * @return void
	 */
	function db_install() {
		global $wpdb;
		$charset_collate = $wpdb->get_charset_collate();

		$mss_files = "CREATE TABLE IF NOT EXISTS $this->scannertablename (
            file_id INT(11) NOT NULL AUTO_INCREMENT,
            path LONGTEXT NOT NULL UNIQUE,
            checksum LONGTEXT NOT NULL,
            sid LONGTEXT NOT NULL,
            type LONGTEXT NOT NULL,
            sver LONGTEXT NOT NULL,
            attrib LONGBLOB,
            PRIMARY KEY (file_id)
        ) $charset_collate;";

		$mss_checksums = "CREATE TABLE IF NOT EXISTS $this->checksumtablename (
            file_id INT(11) NOT NULL AUTO_INCREMENT,
            path LONGTEXT NOT NULL UNIQUE,
            checksum LONGTEXT NOT NULL,
            type LONGTEXT NOT NULL,
            ver LONGTEXT NOT NULL,
            PRIMARY KEY (file_id)
        ) $charset_collate;";

		require_once ABSPATH . 'wp-admin/includes/upgrade.php';
		dbDelta( $mss_checksums );
		dbDelta( $mss_files );
		mss_utils::update_setting( 'db_version', '1.0' );
	}

	/**
	 * Upgrade tables if required
	 *
	 * @return void
	 */
	function upgrade_tables() {
		// $this->db_install();
		$db_version = mss_utils::get_setting( 'db_version' );

		if ( ! $db_version || version_compare( $db_version, '1.0', '<' ) ) {
			$this->db_install();
		}
	}

	/**
	 * Adds a meta_box to admin UI for scanner
	 *
	 * @return void
	 */
	function add_meta_boxes() {
		// $this->flog( __FUNCTION__ );
		add_meta_box( 'mss_scanner', 'Malware Scanner', array( $this, 'scanner_meta_box' ), $GLOBALS['Malcure_security_suite']['pagehook'], 'main' );
	}

	/**
	 * meta_box callback that renders the admin UI for scanner
	 *
	 * @return void
	 */
	function scanner_meta_box() {
		// mss_utils::llog( mss_utils::get_option_definitions() );
		$status = mss_utils::get_option( 'scanner_state' );
		if ( $status ) {
			mss_utils::llog( $status['size'] );
			mss_utils::llog( $status['identifier'] );
			mss_utils::llog( $status );
		}
		// $this->db_install();
		// mss_utils::llog(  ABSPATH  );
		// mss_utils::llog(  mss_utils::realpath( ABSPATH ) );
		// // mss_utils::llog(  get_theme_root()  );
		// return;
		// mss_utils::update_checksums_web();
		// mss_utils::llog( $this->get_definitions() );
		// $this->file_needs_scan( '/var/www/html/dev/plugindev/wp/readme.html' );
		$this->maybe_update_definitions();

		$operations = array(
			'start',
			'stop',
		);
		// $this->flog( __FUNCTION__ );
		// $this->clear_state();

		// mss_utils::llog( $this->is_scan_running() );

		$is_running      = (int) ! empty( $this->is_scan_running() );
		$valid_operation = $operations[ $is_running ];
		echo '<input class="mss_action" style="text-transform:capitalize" value="' . $valid_operation . '" id="mss_scan_btn" type="submit" />';
		echo '<pre>' . print_r( get_option( 'file_indexed_files' ), 1 ) . '</pre>';
		?>
		<ol>
			<li>Validate scan trigger security.</li>
			<li>Implement wp_remote test before scanning</li>
			<li>Implement file scan only if doesn't match checksum</li>
			<li>Implement file scan only if an infected file passes signature id which it failed</li>
			<li>Implement signature id consistency (the generated ones often have updated signature ids)</li>
			<li>Implement scan cancellation</li>
			<li>Implement scan progress monitoring</li>
		</ol>
		<script type="text/javascript">
			jQuery(document).ready(function($){
				
				var mss_operations = <?php echo json_encode( $operations ); ?>;
				mss_is_running = <?php echo (int) $is_running; ?>;
				mss_valid_operation = mss_operations[ mss_is_running ];
				console.log('mss_is_running on Page Load '+ mss_is_running);
				console.log('mss_valid_operation on Page Load '+ mss_valid_operation);
				$('#mss_scan_btn').click(function(){
					//console.log('Initiating Scan');
					console.log('mss_operations:' );
					console.dir( mss_operations);
					console.log('before mss_is_running ' + typeof mss_is_running);
					console.log(mss_is_running);
					
					mss_scan_operation = {
						mss_scan_operation_nonce: '<?php echo wp_create_nonce( 'mss_scan_operation' ); ?>',
						action: "mss_scan_operation",
						operation: mss_valid_operation,

					};
					$.ajax({
						url: ajaxurl,
						method: 'POST',
						data: mss_scan_operation,
						success: function(data, textStatus, jqXHR) {
					
					mss_is_running = Number(! mss_is_running);
					//mss_is_running = mss_operations[ ! mss_is_running ];
					console.log('after mss_is_running '  + typeof mss_is_running);
					console.log(mss_is_running);
					mss_valid_operation = mss_operations[ mss_is_running ];
					console.log('valid_operation: ' + mss_valid_operation);
					$('#mss_scan_btn').val(mss_valid_operation);

							console.dir('success Data Begins');
							console.dir(data);
							console.dir(textStatus);
							console.dir(jqXHR);
							console.dir('success Data Ends');
							// mss_status_updater = setTimeout(mss_update_scan_status,1000);
						},
						error: function( jqXHR, textStatus, errorThrown){},
						complete: function(jqXHR_data, textStatus) {
							console.log('This page needs to reload to watch progress.')
						},
					});
				});
			});
		</script>
		<?php
	}

	function is_scan_running() {
		return $this->has_state();
	}

	function has_state() {
		return ! empty( mss_utils::get_option( 'scanner_state' ) );
	}

	function restore_state() {
		$this->state = mss_utils::get_option( 'scanner_state' );
	}

	/**
	 * Saves the state of indexing
	 *
	 * @return void
	 */
	private function save_state() {
		mss_utils::update_option( 'scanner_state', $this->state );
	}

	/**
	 * Clears the state of indexing
	 */
	private function clear_state() {
		mss_utils::delete_option( 'scanner_state', $this->state );
	}

	/**
	 * Returns the state of the indexing process
	 *
	 * @return void
	 */
	function initialize_state( $jobs = array() ) {
		$state       = array(
			'jobs'       => array(),
			'total'      => 0,
			'files'      => array(),
			'indexed'    => array(),
			'dstack'     => array(),
			'dcounter'   => array(),
			'identifier' => microtime( 1 ),
			'pad'        => 0,
		);
		$state       = array_merge( $state, $jobs );
		$this->state = $state;
		$this->add_to_stack( $this->os_entry_dir );
	}

	public function scan_operation_handler() {
		$this->flog( $_REQUEST );
		// wp_send_json( $_REQUEST );

		if ( ! wp_doing_ajax() ) {
			$this->flog( '! wp_doing_ajax' );
			wp_die();
		}
		// return;
		if ( ! headers_sent() ) {
			// header('Content-type: text/javascript');
			header( 'Connection: close' );
			header( 'Content-Length: 0' );
			// header("X-Robots-Tag: noindex");

		}
		session_write_close();
		ignore_user_abort( 1 );

		if ( ! empty( $_REQUEST['operation'] ) ) {
			$this->start = $_SERVER['REQUEST_TIME']; // used to track max_execution_time
			switch ( $_REQUEST['operation'] ) {
				case 'start':
					if ( $this->is_scan_running() ) {
						$this->flog( 'Scan already running. Aborting.' );
						wp_die();
					}
					$this->flog( 'Start requested' );
					$this->prepare_scan_init();
					$this->index_files_recursively();
					$this->clear_state();
					wp_die();
					break;
				case 'continue':
					$this->flog( 'Continue requested' );
					if ( $this->has_state() ) {
						$this->restore_state();
					} else {
						$this->flog( 'No state found. Aborting.' );
						wp_die();
					}
					$this->index_files_recursively();
					$this->flog( 'Final state before clearing' );
					$this->clear_state();
					wp_die();
					break;
				case 'stop':
					$this->flog( 'Kill requested' );
					wp_send_json( mss_utils::update_setting( 'kill_requested', true ) );
					break;
				default:
					wp_send_json( $this->flog( 'Invalid Operation' ) );
					break;
			}
		}
		wp_send_json( 'Invalid Operation' );
		// $this->flog( __FUNCTION__ );
		if ( ! empty( $_REQUEST['mss_fork'] ) ) {
			$this->flog( '' );
			$this->flog( '' );
			// $this->flog( '================' );
			// $this->flog( '====Fork initiated' );
			// $this->flog( '================' );
		}

		if ( $this->has_state() ) {
			$this->restore_state();
		} else {
			$this->maybe_update_definitions();
			$this->flog( 'Resetting Log.' );
			mss_utils::clear_log();
			$this->flog( 'Creating state.' );
			$this->initialize_state();
			// $this->flog( $this->state );
			$this->save_state(); // save the state so that we can reference the identifier
		}
		$this->index_files_recursively();
		$this->flog( 'Final state before clearing' );
		// unset( $this->state['logged'] );
		$this->flog( $this->state );
		$this->clear_state();
		wp_die();
	}


	/**
	 * Indexes files resursively
	 *
	 * @return void
	 */
	public function index_files_recursively( $passed = array() ) {

		// if ( empty( $this->state['dstack'] ) ) {
		// $this->flog( 'Nothing to index' );
		// return;
		// }
		if ( $passed ) {
			// $this->flog( '$passed' );
			// $this->flog( $passed );
			// $this->flog( 'EXPLICIT STATE LOG CALLED' );
			// $this->log_state( $this->state );
			// $this->flog( 'EXPLICIT STATE LOG ENDS' );
			// exit();
		}
		$dir = $this->state['dstack'][ count( $this->state['dstack'] ) - 1 ];
		// $this->flog( 'dir to index is ' . $dir . ' and its dcounter is ' . $this->state['dcounter'][ $dir ] );
		// $this->state['dcounter'][ $dir ] = isset( $this->state['dcounter'][ $dir ] ) ? $this->state['dcounter'][ $dir ] : 0;
		$entries = @scandir( $dir );
		if ( ! is_array( $entries ) ) {
			$entries = array(); // Initialize an empty array @scandir returns false on failure
		}
		$entries = array_diff( $entries, array( '.', '..' ) );
		natcasesort( $entries );
		$entries = array_values( $entries );
		// $this->state['list'][ $dir ] = $entries;
		// $this->flog( 'Entries of ' . $dir . ' are ' . var_export( $entries, 1 ) );
		// while ( count( $this->state['dstack'] ) ) {
		for ( ;$this->state['dcounter'][ $dir ] < count( $entries ); ) {
			$this->maybe_save_and_fork(); // We are about to start a new directory, so may be save the state and attempt to fork the process
			$location = trailingslashit( $dir ) . $entries[ $this->state['dcounter'][ $dir ] ];
			$this->state['dcounter'][ $dir ]++;

			if ( $this->is_valid_file( $location ) ) {
				// $this->flog( 'Indexed File  :' . $location );
				$this->process_file_scan( $location );
				$this->state['files'][] = $location;
				$this->state['total']++;
				$this->state['size'] = array_key_exists( 'size', $this->state ) ? (int) $this->state['size'] + @filesize( $location ) : @filesize( $location );
				// $this->state['files'][ $location ] = true;
			}
			if ( $this->is_valid_dir( $location ) && ! file_exists( trailingslashit( $location ) . '.mcignore' ) ) {
				// $this->flog( 'Entering into :' . $location );
				$this->add_to_stack( $location );
				$this->index_files_recursively( array( 'recursion' => 'yes' ) );
			}
		}
		// $this->flog( 'Indexing of directory ' . $dir . ' completed. Here is the state before removing from stack.' );
		// $this->log_state( $this->state );
		$this->remove_from_stack( $dir );
		// }

		// Assume we have resumed from a previous state
		// Assume also that the state was recursing into a directory
		// We have just completed a possible recursion
		// We don't know what the previous directory is
		// so attempt to call self
		if ( count( $this->state['dstack'] ) ) {
			// $this->flog( '----R---- There still is something on the stack. Going Up in stack:' );
			// $this->flog( $this->state['dstack'] );
			$this->index_files_recursively(
				array(
					'recursion'   => 'yes',
					'restoration' => 'positive',
				)
			);
		}
	}

	/**
	 * Checks if we are about to hit max_execution_time and forks the process if we are, using curl / wp_remote_*
	 *
	 * @return void
	 */
	public function maybe_save_and_fork() {
		// $this->quit();
		if ( mss_utils::get_setting( 'kill_requested', true ) ) {
			$this->flog( 'Kill requested. Not continuing.' );
			$this->quit();
		}
		$max_execution_time = $this->max_execution_time; // ini_get( 'max_execution_time' ); // Get the max_execution_time
		$start              = $this->start;
		$now                = time();
		$elapsed            = $now - $start;
		$remaining_time     = ( $max_execution_time - $elapsed );
		// $this->flog( '$elapsed:' . $elapsed . ' $remaining_time:' . $remaining_time );

		if ( $remaining_time <= $this->time_buffer ) { // If there are 2 seconds or less remaining, save the data and exit
			// $this->flog( __FUNCTION__ );
			// $this->flog('Saving state before forking');
			// $this->flog($this->state);
			$this->save_state();
			$url = admin_url( 'admin-ajax.php?action=mss_scan_operation&mss_fork=1&&operation=continue' );
			$this->flog( str_repeat( "\t\t\t", $this->state['pad'] ) . 'Forking to ' . $url . ' because of remaining_time:' . $remaining_time . ' max_execution_time: ' . $max_execution_time . ' $start:' . $start . ' now:' . $now . ' elapsed: ' . $elapsed );
			$fork = @wp_remote_get(
				$url,
				array(
					'timeout'   => 0.01,
					'blocking'  => false,
					'sslverify' => false,
					'headers'   => array(
						'mss_fork' => '1',
					),
				)
			);
			// $this->flog( $fork );
			// error_log( 'Exiting because of remaining_time:' . $remaining_time );
			exit( 0 );
			// wp_die();
		} else {
		}
	}

	function quit() {
		$this->clear_state();
		mss_utils::delete_setting( 'kill_requested', true );
		wp_die();
	}

	function add_to_stack( $location ) {
		array_push( $this->state['dstack'], $location );
		$this->state['dcounter'][ $location ] = 0;
		// $this->flog( 'Added ' . $location . ' to stack' );
	}

	function remove_from_stack( $dir ) {
		// $this->flog( 'Removing ' . $dir . ' from stack by ' . __FUNCTION__ . ' Here\'s the directory in the stack' );
		if ( empty( $this->state['dstack'][ $dir ] ) ) {
			// $this->flog( 'Empty received. Attempting removal' );
			$this->state['dstack'] = array_filter(
				$this->state['dstack'],
				function( $value ) use ( $dir ) {
					return $value !== $dir;
				}
			);
			// $this->flog( 'After removal' );
			// $this->log_state( $this->state );
		} else {
			$this->flog( 'Something went wrong> Killing self' );
			die();
		}
		// $this->flog( $this->state['dstack'][ $dir ] );
		// unset( $this->state['dstack'][ $dir ] );
		// $this->flog( 'State after Removing ' );
		// $this->log_state( $this->state );
		// $removed = array_pop( $this->state['dstack'] );
		// $this->flog( 'Removed ' . $removed . ' from stack' );
		// return $removed;
		// $this->state['dcounter'][ $location ] = 0;
	}

	function waste_time( $seconds ) {
		$start_time = time();

		$this->number = 1.61803398874989484820458683436563811772030917980576286213544862270526046281890;
		// $this->flog( 'Need to waste ' . $seconds . ' seconds' );
		while ( true ) {
			$elapsed_time   = time() - $start_time;
			$remaining_time = $this->max_execution_time - $elapsed_time;
			$remaining_time = $this->max_execution_time - $elapsed_time;
			// $this->flog( 'elapsed_time: ' . $elapsed_time . ' remaining_time: ' . $remaining_time );
			if ( $remaining_time <= $seconds || $remaining_time <= $this->time_buffer ) {
				// $this->flog( 'BREAKING elapsed_time: ' . $elapsed_time . ' remaining_time: ' . $remaining_time . ' time_buffer: ' . $this->time_buffer );
				break;
			}
			// Get the prime factors of the current number
			$this->number = $this->number * ( 1 + sqrt( 5 ) ) / 2;
		}
	}

	/**
	 * Request a malware scan of the file via ajax / wp_remote_
	 *
	 * @param [type] $file
	 * @return void
	 */
	function process_file_scan( $file ) {
		// $this->waste_time( 1 );
		// $this->flog( __FUNCTION__ . ' for ' . $file );
		// usleep( 10000 ); // 10000 = 10ms
		// return;

		// First run checks if the file matches or needs a thorough scan
		if ( ! $this->file_needs_scan( $file ) ) {
			return;
		}
		// return;
		// If it matches, then we don't need to scan it

		$data = $this->exor(
			array(
				'type' => 'file',
				'path' => $file,
			)
		);
		// $this->flog( 'data ' . $data );
		$url = admin_url(
			'admin-ajax.php?action=mss_scan_file&data=' . $data
		);
		// $this->flog( __FUNCTION__ . ' url ' . $url );
		$response = wp_remote_get(
			$url,
			array(
				'timeout'   => 0.01,
				'blocking'  => false,
				'sslverify' => false,
				'headers'   => array(
					'mss_scan' => '1',
				),
			)
		);

		// $this->flog( 'response' );
		// $this->flog( $response );
	}

	function file_needs_scan( $file_path ) {
		$file_path = mss_utils::realpath( $file_path );
		// $this->flog( 'checking if file needs scan ' . $file_path );
		global $wpdb;

		$checksum = @hash_file( 'sha256', $file_path );
		if ( ! $checksum ) {
			$this->flog( 'File not accessible ' . $file_path );
			return false;
		}
		// $checksum = $checksum . 'k'; // simulate a fake checksum
		$cs_query = $wpdb->prepare(
			"SELECT 
                file_id, 
                path, 
                checksum, 
                type, 
                ver 
            FROM {$this->checksumtablename} 
            WHERE path = %s AND checksum = %s",
			$file_path,
			$checksum
		);

		$checksum_matches = $wpdb->get_results( $cs_query, ARRAY_A );

		// $this->flog( '$checksum_matches' );
		// $this->flog( $checksum_matches );
		if ( empty( $checksum_matches ) ) {
			// $this->flog( 'File needs scan ' . $file_path );
			$gencs_query = $wpdb->prepare(
				"SELECT 
                    
                    path, 
                    checksum, 
                    sid, 
                    type,
                    sver,attrib 
                FROM {$this->scannertablename} 
                WHERE path = %s AND checksum = %s",
				$file_path,
				$checksum
			);

			$checksum_generated = $wpdb->get_results( $gencs_query, ARRAY_A );
			if ( empty( $checksum_generated ) ) {
				return true;
			} else {
				// check if this file is infected or not
				// if so, attempt to scan against the flagged sigid
				// if sigid is missing or the file passes, then the file should be scanned
				// else not

				return $this->file_passes_against_sigid();
			}
		} else {
			return false;
			// $this->flog( 'File does not need scan ' . $file_path );
		}
		$this->flog( '$checksum_matches' );
		$this->flog( $checksum_matches );
		// Array
		// (
		// [0] => Array
		// (
		// [file_id] => 1
		// [path] => /_extvol_data/html/dev/plugindev/wp/index.php
		// [checksum] => eea9347b1e266ca5407b92633958c148dbfebea307e511a3a226ea61828e2eba
		// [type] => core
		// [ver] => 6.1.3
		// )
	}

	function file_passes_against_sigid() {
        return true;
        //file is clean?
        //    scan
        //file was infected against sigid?
        //    sigid exists?
        //        skip // don't need to scan because it was already scanned against this sigid
        //    sigid missing?
        //        scan // maybe the sigid was updated

        // if(file was infected against a sigid && sigid exists)
	}

	function is_table_empty( $table_name ) {
		global $wpdb;
		$table_name = sanitize_text_field( $table_name ); // Sanitize the table name to ensure it's a valid SQL identifier
		$count      = $wpdb->get_var( "SELECT COUNT(*) FROM $table_name" ); // Query to count the number of rows in the table
		return $count == 0; // Check if the count is zero
	}


	function prepare_scan_init() {
		if ( $this->is_table_empty( $this->scannertablename ) ) {
			mss_utils::update_checksums_web();
		}
		$this->maybe_update_definitions();
		$this->initialize_state();
		$this->save_state(); // save the state so that we can reference the identifier
	}

	/**
	 * Scan the file for malware
	 *
	 * @return void
	 */
	function scan_file() {
		if ( ! wp_doing_ajax() ) {
			$this->flog( '! wp_doing_ajax' );
			wp_die();
		}
		if ( ! headers_sent() ) {
			// header('Content-type: text/javascript');
			header( 'Connection: close' );
			header( 'Content-Length: 0' );
			// header("X-Robots-Tag: noindex");
		}
		session_write_close();
		ignore_user_abort( 1 );
		$sec = mss_utils::get_option( 'scanner_state' );
		if ( empty( $sec ) || empty( $sec['identifier'] ) ) {
			$this->flog( 'Identifier is empty. Aborting.' );
			wp_die();
		}

		$sec = (string) $sec['identifier'];

		$data = $this->dxor( $_REQUEST['data'], $sec );

		if ( ! empty( $data['type'] ) && ! empty( $data['path'] ) ) {
			$this->flog( 'scanning: ' . $data['path'] );
			$this->scan_file_threats( $data['path'] );
		} else {
			$this->flog( 'something wrong with data: ' );
			$this->flog( 'identifier: ' . $sec );
			$this->flog( $_REQUEST );
			$this->flog( '$data' );
			$this->flog( $data );
		}
		wp_die(); // this is required to terminate immediately and return a proper response
	}

	function exor( $data ) {
		if ( empty( $this->state['identifier'] ) ) {
			$this->flog( 'exor identifier is empty' );
			return false;
		}
		$key    = (string) $this->state['identifier'];
		$data   = json_encode( $data );
		$output = '';
		// $this->flog('Key:' . $key . ' strlen:' . strlen( $key ));
		for ( $i = 0; $i <
		strlen( $data ); $i++ ) {
			$output .= $data[ $i ] ^
			$key[ $i %
			strlen( $key ) ];
		}
		return urlencode( base64_encode( $output ) );
	}

	function dxor( $data, $key ) {
		$key  = (string) $key;
		$data = base64_decode( urldecode( $data ) );
		if ( empty( $data ) ) {
			return false; // base64_decode returns false in case of failure
		}
		$output = '';
		for ( $i = 0; $i < strlen( $data ); $i++ ) {
			$output .= $data[ $i ] ^
			 $key[ $i %
			  strlen( $key ) ];
		}
		$data = json_decode( $output, true );
		if ( empty( $data ) ) {
			return false; // json_decode returns null in case of failure
		}
		return $data;
	}

	function get_fileext( $filename ) {
		$nameparts = explode( '.', ".$filename" );
		return strtolower( $nameparts[ ( count( $nameparts ) - 1 ) ] );
	}

	function scan_file_threats( $file ) {
		$this->is_valid_file( $file );
		$file_contents = @file_get_contents( $file );
		$ext           = $this->get_fileext( $file );
		$tests         = array();

		$definitions = $this->get_malware_file_definitions();

		$sver = $this->get_definition_version();
		if ( strpos( @ini_get( 'disable_functions' ), 'ini_set' ) === false ) {
			@ini_set( 'pcre.backtrack_limit', 1000000 );
		}

		foreach ( $definitions as
		$definition =>
		$signature ) {
			if ( $signature['class'] == 'htaccess' && $ext != 'htaccess' ) {
				continue;
			}
			try {
				$matches = preg_match( $this->decode( $signature['signature'] ), $file_contents, $found );
			} catch ( Exception $e ) {
				$this->flog( 'Faulty Signature: ' . $definition );
				$this->flog( 'Faulty Pattern: ' . $this->decode( $signature['signature'] ) );
				$this->flog( 'File: ' . $file );
				$this->flog( $e->getMessage() );
				continue;
			}
			if ( $matches >= 1 ) {
				$this->flog( 'Definite match found in ' . $file );
				$this->flog( $matches );
				if ( in_array( $signature['severity'], array( 'severe', 'high' ) ) ) {
					$this->update_setting( 'infected', true );
				}
				// return array(
				// 'id'       => $definition,
				// 'severity' => $signature['severity'],
				// 'info'     => $signature['severity'],
				// );
				return $this->save_file_status( $file, $definition, $signature['severity'], $sver );
			}
			return $this->save_file_status( $file, '', '', $sver );
		}

	}

	function save_file_status( $file, $definition_id, $status, $sver ) {
		global $wpdb;

		// Table name
		$table_name = $this->scannertablename;

		$checksum = @hash_file( 'sha256', $file );
		if ( ! $checksum ) {
			$checksum = '';
		}
		// file_id
		// path
		// checksum
		// status
		// type
		// sver
		// attrib

		$query  = $wpdb->prepare( // Prepare the query
			"INSERT INTO $table_name ( path, checksum, sid, sver) VALUES (%s, %s, %s, %s) 
            ON DUPLICATE KEY UPDATE checksum = VALUES(checksum), sid = VALUES(sid), sver = VALUES(sver)",
			$file,
			$checksum,
			$definition_id,
			$sver
		);
		$result = $wpdb->query( $query );       // Execute the query
		return $result;
	}

	/**
	 * Checks if a directory is valid and can be scanned
	 */
	function is_valid_dir( $dir ) {
		// if ( is_dir( $dir ) && ! is_link( $dir ) && ! preg_match( '/\.git\b/', $dir ) ) {
		if ( is_dir( $dir ) && ! is_link( $dir ) && is_readable( $dir ) ) {
			return true;
		}
	}

	/**
	 * Checks if a file is valid and can be scanned
	 *
	 * @param [type] $file
	 * @return void
	 */
	function is_valid_file( $file ) {
		// if ( is_file( $file ) && ! is_link( $file ) ) {
		if ( is_file( $file ) && ! is_link( $file ) && is_readable( $file ) && filesize( $file ) && filesize( $file ) < $this->filemaxsize ) {
			return true;
		}
	}

	/**
	 * Logging function for debugging that utilizes var_dump
	 *
	 * @param [type] $obj
	 * @return void
	 */
	function get_dump( $obj ) {
		ob_start();
		var_dump( $obj );
		$result = ob_get_clean();
		return $result;
	}

	/**
	 * Logging function for debugging that utilizes print_r
	 *
	 * @param [type] $str
	 * @return void
	 */
	function flog( $str ) {
		// $s = print_r(debug_backtrace()[1],1);
		// mss_utils::flog( debug_backtrace()[1]  );
		// mss_utils::flog( debug_backtrace()[1]['function'] );
		// mss_utils::flog( debug_backtrace()[1]['line'] );
		mss_utils::flog( $str );
		return true;
	}

	function decode( $str ) {
		return json_decode( base64_decode( strtr( $str, '-_,', '+/=' ) ), true );
	}

	function maybe_update_definitions() {
		if ( mss_utils::definition_updates_available() ) {
			$this->flog( 'definition updates available' );
			return mss_utils::update_definitions();
		} else {
			$this->flog( 'no definition updates available' );
		}
	}

	function get_definitions() {
		$definitions = mss_utils::get_option_definitions();
		if ( ! empty( $definitions ) ) {
			return $definitions;
		} else {
			$this->flog( 'no definitions' );
		}
	}

	/**
	 * Returns the version of the definitions
	 *
	 * @return void
	 */
	function get_definition_version() {
		$definitions = mss_utils::get_option_definitions();
		if ( $definitions && ! empty( $definitions['v'] ) ) {
			return $definitions['v'];
		}
	}

	/**
	 * Gets malware definitions for database only
	 *
	 * @return void
	 */
	function get_malware_db_definitions() {
		$defs = mss_utils::get_option_definitions();
		if ( ! empty( $defs['definitions']['db'] ) ) {
			return $defs['definitions']['db'];
		}
	}

	/**
	 * Gets malware definitions for files only
	 */
	function get_malware_file_definitions() {
		$defs = $this->get_definitions();
		// $this->flog($defs);
		if ( ! empty( $defs['definitions']['files'] ) ) {
			return $defs['definitions']['files'];
		} else {
			$this->flog( 'no defs' );
			return array();
			// $this->flog($defs);
		}
	}

}

Malcure_Malware_Scanner::get_instance();
