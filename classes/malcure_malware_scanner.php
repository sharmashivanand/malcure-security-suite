<?php
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

define( 'MSS_ORIGIN_CS', 'mss_origin_cs' );
define( 'MSS_GEN_CS', 'mss_gen_cs' );
define( 'MSS_ISSUES', 'mss_issues' );

/**
 * Singleton Class for WordPress File Indexer
 */

// todo: elapsed time during each phase should be in human readable format
final class Malcure_Malware_Scanner {

	private static $instance    = null;
	private $state              = false;
	private $tablename          = '';
	private $max_execution_time = false;
	private $os_entry_dir       = false;
	private $time_buffer        = 5;
	private $definitions        = false;
	private $mss_origin_cs      = false;
	private $mss_gen_cs         = false;
	private $mss_issues         = false;

	public $filemaxsize = 1111111; // 1085.069336 KB || 1.0596380234375 MB

	private function __construct() {
	}

	/**
	 * Singleton instance
	 *
	 * @return void
	 */
	public static function get_instance() {
		if ( self::$instance === null ) {
			self::$instance = new self();
			self::$instance->init();
		}
		return self::$instance;
	}

	/**
	 * Initializes hooks and filters
	 *
	 * @return void
	 */
	function init() {

		$this->max_execution_time = ini_get( 'max_execution_time' ); // Get the max_execution_time
		$this->max_execution_time = ! is_numeric( $this->max_execution_time ) || $this->max_execution_time < 30 ? 15 : min( $this->max_execution_time, 90 );

		$backtrackLimit = ini_get( 'pcre.backtrack_limit' );
		if ( is_numeric( $backtrackLimit ) ) {
			$backtrackLimit = (int) $backtrackLimit;
			if ( $backtrackLimit > 1000000 ) {
				ini_set( 'pcre.backtrack_limit', 1000000 );
				ini_set( 'pcre.recursion_limit', 1000000 );
			}
		}

		$this->mss_origin_cs = $GLOBALS['wpdb']->prefix . MSS_ORIGIN_CS;
		$this->mss_gen_cs    = $GLOBALS['wpdb']->prefix . MSS_GEN_CS;
		$this->mss_issues    = $GLOBALS['wpdb']->prefix . MSS_ISSUES;

		$this->os_entry_dir = untrailingslashit( ABSPATH );

		add_action( 'Malcure_security_suite_add_meta_boxes', array( $this, 'add_meta_boxes' ), 8 );

		add_action( 'wp_ajax_nopriv_scanner_ajax_dispatcher', array( $this, 'user_ajax_dispatcher' ) );
		add_action( 'wp_ajax_scanner_ajax_dispatcher', array( $this, 'user_ajax_dispatcher' ) );

		add_action( 'wp_ajax_nopriv_mss_scan_operation', array( $this, 'scan_operation_handler' ) );
		add_action( 'wp_ajax_mss_scan_operation', array( $this, 'scan_operation_handler' ) );

		add_action( 'wp_ajax_nopriv_mss_scan_file', array( $this, 'scan_file_callback' ) );
		add_action( 'wp_ajax_mss_scan_file', array( $this, 'scan_file_callback' ) );

		add_action( 'wp_ajax_nopriv_mss_scan_db', array( $this, 'scan_db_callback' ) );
		add_action( 'wp_ajax_mss_scan_db', array( $this, 'scan_db_callback' ) );

		add_action( 'wp_ajax_mss_scan_status', array( $this, 'scan_status_callback' ) );

		add_action( 'mss_plugin_activation', array( $this, 'db_install' ) );
		add_action( 'plugins_loaded', array( $this, 'upgrade_tables' ) );
		add_action( 'upgrader_process_complete', array( $this, 'fetch_checksums' ), 10, 2 );

		// add_filter( 'heartbeat_received', array( $this, 'heartbeat_callback' ), 10, 2 );

		add_action( 'mss_scan_phase_filemalwarescan', array( $this, 'phase_filemalwarescan' ) );
		add_action( 'mss_scan_phase_dbmalwarescan', array( $this, 'phase_dbmalwarescan' ) );

		// add_filter( 'heartbeat_settings', array( $this, 'custom_heartbeat_settings' ) );

		// add_filter('use_curl_transport', '__return_false');
	}


	/**
	 * Adds a meta_box to admin UI for scanner
	 *
	 * @return void
	 */
	function add_meta_boxes() {
		add_meta_box( 'mss_scanner', 'Malware Scanner', array( $this, 'scanner_meta_box' ), $GLOBALS['Malcure_security_suite']['pagehook'], 'main' );
	}

	/**
	 * meta_box callback that renders the admin UI for scanner
	 *
	 * @return void
	 */
	function scanner_meta_box() {
		// $this->term_scan_routines();
		// $this->clear_state();
		// mss_utils::delete_setting( 'kill_requested' );
		// mss_utils::delete_option( 'continue_token' );
		$url = admin_url( 'admin-ajax.php?action=mss_scan_operation&operation=mss_test' );

		$test_start   = time();
		$response     = @wp_remote_get(
			$url,
			array(
				'timeout'   => ( $this->max_execution_time - $this->time_buffer ) - 5, // the test should complete within PHP max_execution_time including the time_buffer and 5 seconds for the request
				'blocking'  => true,
				'sslverify' => false,
				'headers'   => array(
					'mss_fork' => '1',
					'Host'     => parse_url( site_url(), PHP_URL_HOST ),
				),
			)
		);
		$test_end     = time();
		$duration_raw = $test_end - $test_start;
		$duration_raw = round( $duration_raw, 2 );

		$server_time = 0;
		if ( is_wp_error( $response ) ) {
			$error_message = $response->get_error_message();
			echo "<p>Scanner failed test: $error_message</p>";
			echo '<p>Your hosting may be slow or not compatible with the scanner.</p>';
		} else {
			$status_code = wp_remote_retrieve_response_code( $response );           // Check the HTTP response code
			if ( $status_code == 200 ) {                // The request was successful
				$body = wp_remote_retrieve_body( $response );
				$body = json_decode( $body, true );
				if ( ! is_null( $body ) ) {
					if ( ! empty( $body['success'] ) && ! empty( $body['data'] ) && ! empty( $body['data']['mss_test'] ) ) {
						$server_time = round( $body['data']['mss_test'] - $test_start, 2 );
						$operations  = array(
							'start',
							'stop',
						);

						$is_running      = (int) ! empty( $this->has_state() );
						$valid_operation = $operations[ $is_running ];
						$mss_specs       = mss_utils::get_plugin_data();
						// mss_utils::llog($mss_specs);
						?>
						<script type="text/javascript">
							mss_scrolled = false;
							mss_operations = <?php echo json_encode( $operations ); ?> ;
							mss_scan_running = <?php echo (int) $is_running; ?>;
							mss_valid_operation = '<?php echo $valid_operation; ?>';
						</script>
						<table id="mss_scan_hud">
							<tr id="top-row">
								<td class="left-col"><table id="mss-top-left"><tr><td class="mss_label">WordPress</td><td class="mss_value"><?php echo get_bloginfo( 'version' ); ?></td></tr><tr><td class="mss_label">Plugin Version:</td><td class="mss_value"><?php echo $mss_specs['Version']; ?></td></tr><tr><td class="mss_label">PHP:</td><td class="mss_value"><?php echo phpversion(); ?></td></tr><tr><td class="mss_label">Server:</td><td class="mss_value"><?php echo $_SERVER['SERVER_SOFTWARE']; ?></td></tr><tr><td class="mss_label">Memory Limit:</td><td class="mss_value"><?php echo @ini_get( 'memory_limit' ); ?></td></tr></table></td><td class="middle-col">Powered by Malcure Malware Scanner</td>
							</tr>
							<tr id="middle-row">
								<td class="left-col"></td><td class="middle-col"><div id="mss_screen" class="mss_status_<?php echo $valid_operation; ?>"><div id="mss_progress" class="mss_progress scan_updates"></div></div></td>
							</tr>
							<tr id="bottom-row">
								<td class="left-col"><?php echo "<table><tr><td>Diagnostic Response:</td><td>$duration_raw;</td></tr><tr><td>Server response:</td><td>" . $server_time . ';</td></tr></table>'; ?></td><td class="middle-col">
																<?php
																echo '<p><input class="mss_action" style="text-transform:capitalize" value="' . $valid_operation . '" id="mss_scan_btn" type="submit" /></p>';
																?>
												</td>
							</tr>
						</table>
						
						<div id="mss_scan_results"></div>
						<script type="text/javascript">
							function mss_dirname(path) {
								return path.replace(/\\/g, '/').replace(/\/[^\/]*$/, '');
							}
							var mss_results = {}; 
							var mss_status_updater = false;
							jQuery(document).ready(function($){
								mss_get_status(); // at least show something right away
								mss_valid_operation = mss_operations[ mss_scan_running ];
								console.log('mss_scan_running on Page Load '+ mss_scan_running);
								console.log('mss_valid_operation on Page Load '+ mss_valid_operation);
								$('#mss_scan_btn').click(function(){
									$('#mss_scan_btn').attr('disabled', 'disabled');
									mss_user_operation = {
										mss_user_operation_nonce: '<?php echo wp_create_nonce( 'mss_user_operation' ); ?>',
										action: "scanner_ajax_dispatcher",
										operation: mss_valid_operation,
									};
									$.ajax({
										url: ajaxurl,
										dataType: "text",
										method: 'POST',
										timeout: 15000, // 15s
										data: mss_user_operation,
										success: function(data, textStatus, jqXHR) {
											console.dir('success Data Begins');
											console.dir('data');
											console.dir(data);
											console.dir('textStatus');
											console.dir(textStatus);
											console.dir('jqXHR');
											console.dir(jqXHR);
											console.dir('jqXHR');
											$('#mss_scan_btn').removeAttr('disabled');
											update_scanner_ui();
										}, // success end
										error: function( jqXHR, textStatus, errorThrown){
											console.dir('error Data Begins');
											console.dir('jqXHR');
											console.dir(jqXHR);
											console.dir('textStatus');
											console.dir(textStatus);
											console.dir('errorThrown');
											console.dir(errorThrown);
										}, // error end
										complete: function(jqXHR, textStatus) {
											console.log('completion Data Begins')
											console.dir('jqXHR');
											console.dir(jqXHR);
											console.dir('textStatus');
											console.dir(textStatus);
										}, // complete end
									}); // ajax end
								}); // click end
							});

							/**
							 * Toggles the state of the UI button for triggering scan.
							 *
							 * @return void
							 */
							function update_scanner_ui(){
								mss_scan_running = Number(mss_scan_running);
								if(mss_scan_running) {
									// document.getElementById("mss_scan_results").innerHTML = "";
								}
								else {
									jQuery('#mss_progress').html('');
									if(! mss_scrolled){
										mss_scrolled = true;
										setTimeout( function(){
											jQuery('html,body').animate({
												scrollTop: jQuery('#mss_scan_results').offset().top
											}, 'slow');
										}, 1000);
									}
								}
								mss_valid_operation = mss_operations[ mss_scan_running ];
								jQuery('#mss_screen').attr('class', 'mss_status_'+mss_valid_operation);
								jQuery('#mss_scan_btn').val(mss_valid_operation);
							} // update scanner_ui end
							
							/**
							 * Fetches scan status from the server.
							 * This is the function for updating the UI with the scan-progress and other sci-fi details.
							 */
							function mss_get_status( recurring = true ){
								mss_scan_status = {
									mss_scan_status_nonce: '<?php echo wp_create_nonce( 'mss_scan_status' ); ?>',
									action: "mss_scan_status",
								};
								jQuery.ajax({
									url: ajaxurl,                                    
									data: mss_scan_status,
									success: function(data, textStatus, jqXHR) {
										if(jqXHR.hasOwnProperty('responseJSON')){ // we got json
											mss_scan_status = jqXHR.responseJSON;
											mss_scan_running = false;
											if(mss_scan_status.hasOwnProperty('running') && mss_scan_status.running){ // scan is running
												mss_scan_running = true;
											}
											else{
												mss_scan_running = false;
											}
											if(mss_scan_status.hasOwnProperty('issues')) {
												// console.dir('got issues');
												// console.dir(jQuery('#mss_scan_results'));
												jQuery('#mss_scan_results').html('<div id="mss_scan_issues"></div>');
												issues_html = '';
												mss_scan_status.issues.forEach(function(issue){
													if(issue.hasOwnProperty('comment') && issue.hasOwnProperty('severity')){
														comment = JSON.parse(issue.comment);
														details = JSON.parse(issue.details);
														issues_html = issues_html + '<a class="mss_scan_issue '+issue.severity+' infection_url" target="_blank" href="<?php echo MSS_WEB_EP; ?>?p=2074&ssig='+details.infection_id+'&utm_source=mssissue&utm_medium=web&utm_campaign=mssplugin">'+comment.message+'</a>';
													}
													else{
														console.dir('issue has no comment and severity');
													}
												});
												jQuery('#mss_scan_issues').html(issues_html);
											} // if(mss_scan_status.hasOwnProperty('issues')) end
											else {
												console.dir('no issues');
											}
											if(mss_scan_status.hasOwnProperty('job_status')){
												html = ''
												Object.values( mss_scan_status.job_status ).forEach(job => {
													if (job.message) {
														html += job.message + '<br />' ;
														// console.dir(job.message);
													}
												});
												jQuery('#mss_progress').addClass('scan_update').delay(800).queue(function(next){
													jQuery(this).html(html);
													next();
												}).delay(1200).queue(function(next){
													jQuery(this).removeClass('scan_update');
													next();
												});	//$('#mss_progress').html(mss_scan_status.progress);
											} // if(mss_scan_status.hasOwnProperty('job_status')) end
										} // if(jqXHR.hasOwnProperty('responseJSON')) end
									}, // success end
									error: function( jqXHR, textStatus, errorThrown){
									},
									complete: function(jqXHR, textStatus) {
										if(jqXHR.hasOwnProperty('responseJSON')){ // we got json
											setTimeout(mss_get_status, 2 * 1000);
											update_scanner_ui(mss_scan_running);
										} // if jqXHR.hasOwnProperty('responseJSON') end
									}, // complete end
								}) // ajax end
							} // mss_get_status end
							
							/**
							 * Sets the timer to fetch scan status
							 *
							 * @return void
							 */
							function init_mss_updater(){
								//mss_status_updater = setInterval(mss_get_status,<?php echo ( ( $this->max_execution_time - $this->time_buffer ) / 2 ); ?> * 1000) ;
								if(! mss_status_updater){
									mss_status_updater = setInterval(mss_get_status, 2 * 1000) ;
									// mss_status_updater = setInterval(mss_get_status, 7.5 * 1000) ;
								}
							}

							/**
							 * Clears the timer to fetch scan status once scan is complete or cancelled.
							 *
							 * @return void
							 */
							function stop_scan_routines(){
								console.dir('stopping scan routines');
								console.dir(mss_status_updater);
								clearInterval(mss_status_updater);
								jQuery('#mss_screen').removeAttr('class');
							}
						</script>
						<?php
					} else {
						echo 'Scanner Disabled. Incapable server: <pre>' . htmlentities( print_r( $body, 1 ) ) . '</pre>';
					} // empty( $body['success'] end if/else
				} else {
					echo '<p>Scanner Disabled. Invalid JSON returned: </p><pre>' . htmlentities( $body ) . '</pre>';
				} // is_null end if/else
			} else {
				echo "<p>Scanner Disabled. Scanner failed test. Unexpected status code: $status_code</p>";
			} // status_code end if/else
		}  // wp_error end if/else
	}

	/**
	 * Sends scan status to the client
	 *
	 * @return json object
	 */
	function scan_status_callback() {
		$state  = mss_utils::get_option( 'scanner_state' );
		$issues = $this->get_issues();
		if ( $this->has_state() ) {
			// $this->attempt_continue_broken();
		}
		if ( 0 && $state ) {
			$state['identifier'] = explode( '.', $state['identifier'] )[0];
			if ( ! empty( $status['phase_filemalwarescan_start'] ) ) {
				$state['phase_filemalwarescan_start'] = explode( '.', $state['phase_filemalwarescan_start'] )[0];
			}
			$state['now']     = time();
			$state['issues']  = $issues;
			$state['running'] = ! empty( mss_utils::get_setting( 'scan_handshake_key' ) ) ? true : false;
			wp_send_json( $state );
		}
		wp_send_json(
			array(
				'running' => ! empty( mss_utils::get_setting( 'scan_handshake_key' ) ) ? true : false,
				'issues'  => $issues,
				'state'   => false,
			)
		);
	}

	/**
	 * Dispatches a request to the server based on user-action
	 * Also a workaround to issue a request and return without waiting for PHP to finish processing the request
	 *
	 * @return void
	 */
	function user_ajax_dispatcher() {

		check_ajax_referer( 'mss_user_operation', 'mss_user_operation_nonce' );
		// Check if the user has privileges
		if ( ! current_user_can( 'manage_options' ) ) {
			wp_send_json_error( 'Unauthorized request.' );
			exit;
		}

		// Check if the operation is valid
		$allowed_operations = array( 'mss_test', 'start', 'stop' );
		if ( ! isset( $_REQUEST['operation'] ) || ! in_array( $_REQUEST['operation'], $allowed_operations ) ) {
			wp_send_json_error( 'Invalid operation.' );
			exit;
		}

		// Get the path to admin-ajax.php using admin_url()
		$url = admin_url( 'admin-ajax.php' );

		// Set the URL to the server's own domain using SERVER_NAME
		$url = $this->get_self_url( $url );
		$this->flog( 'url: ' . $url );
		$method = $_SERVER['REQUEST_METHOD'];
		// Prepare the request arguments
		$args = array(
			'method'    => $_SERVER['REQUEST_METHOD'],
			'timeout'   => 5,
			'blocking'  => true,
			'sslverify' => false,
			'headers'   => array(
				'Host' => parse_url( site_url(), PHP_URL_HOST ), // Set the Host header for SNI
			),

			'cookies'   => array(),
		);

		$_REQUEST['action'] = 'mss_scan_operation';
		$mss_nonce          = $this->create_mss_nonce( $_REQUEST['action'] );

		$_REQUEST['mss_nonce'] = $mss_nonce;
		if ( $method === 'POST' ) {
			// $_POST['action'] = 'mss_scan_operation';
			$args['body'] = $_REQUEST;
		} else {
			// $_GET['action'] = 'mss_scan_operation';
			// Append $_GET parameters to the URL for GET requests
			$url = add_query_arg( $_REQUEST, $url );
		}
		$this->flog( '$url' );
		$this->flog( $url );
		$this->flog( '$args' );
		$this->flog( $args );
		// Make the request
		$response = wp_remote_request( $url, $args );
		$this->flog( '$response code' );
		$this->flog( wp_remote_retrieve_response_code( $response ) );

		// Return the response
		if ( is_wp_error( $response ) ) {
			wp_send_json_error( $response->get_error_message() );
		} else {
			$this->flog( __FUNCTION__ . ' received body ' . print_r( $response['body'], 1 ) );
			wp_send_json_success( $response['body'] );
		}
	}

	/**
	 * Main entry to scanner engine
	 *
	 * @return void
	 */
	public function scan_operation_handler() {
		if ( empty( $_REQUEST['operation'] ) ) {
			wp_die();
		}

		if ( $_REQUEST['operation'] == 'mss_test' ) {
			mss_utils::test_local_url();
			$this->maybe_update_definitions(); // run once so that we don't waste time during the initialisation of the scan
			wp_send_json_success( array( 'mss_test' => time() ) );
		}

		$this->accept_async_handover();

		if ( empty( $this->definitions ) ) {
			$this->definitions = $this->get_definitions();
		}

		// FORCE KILL OVER 4 HOURS
		$saved_state = mss_utils::get_option( 'scanner_state' );
		if ( ! empty( $saved_state ) && ! empty( $saved_state['identifier'] ) ) {
			$identifier = $saved_state['identifier'];
			$identifier = explode( '.', $identifier );
			if ( count( $identifier ) == 2 && ( time() - $identifier[0] > 14400 ) ) {
				$this->flog( 'ERROR Scan has been running for over 4 hours. FORCING KILL.' );
				mss_utils::update_setting( 'kill_requested', true );
				mss_utils::delete_option( 'scanner_state' );
			}
		}

		switch ( $_REQUEST['operation'] ) {
			case 'start':
				$this->verify_mss_nonce( $_REQUEST['mss_nonce'], $_REQUEST['action'] );
				if ( $this->has_state() ) {
					$this->flog( 'ERROR Scan already running. Aborting.' );
					wp_send_json_error( 'Scan already running. Aborting.' );
				}
				$this->flog( 'INFO Start requested' );
				$this->init_scan_routines();
				$this->trigger_job();
				$this->term_scan_routines();
				wp_send_json_success( 'Scan started.' );
				break;
			case 'continue':
				// sleep( 1 );
				$this->validate_scan_routines();
				$this->trigger_job();
				$this->flog( 'INFO Scan completed in ' . mss_utils::human_readable_time_diff( explode( '.', $this->state['identifier'] )[0], time() ) );
				$this->term_scan_routines();
				wp_send_json_success( 'Scan completed.' );
				break;
			case 'stop':
				$this->verify_mss_nonce( $_REQUEST['mss_nonce'], $_REQUEST['action'] );
				$this->flog( 'WARNING Stop requested. Scan will cancel after current iteration.' );
				$result = mss_utils::update_setting( 'kill_requested', true );
				$this->flog( 'mss_utils::update_setting( \'kill_requested\', true ) result ' . print_r( get_option( 'MSS' ), 1 ) );
				wp_send_json_success( get_option( 'MSS' ) );
				break;
			default:
				check_ajax_referer( 'mss_scan_operation', 'mss_scan_operation_nonce' );
				wp_send_json_error( $this->flog( 'ERROR Invalid Operation.' ) );
				break;
		}

		$this->flog( 'ERROR: We should never land here. Missing operation or broken switch.' );
		check_ajax_referer( 'mss_scan_operation', 'mss_scan_operation_nonce' );
		wp_send_json( 'Invalid Operation' );
	}

	/**
	 * Setup && Prepare the scan for initiation
	 */
	function init_scan_routines() {
		if ( $this->is_table_empty( $this->mss_origin_cs ) ) {
			$this->flog( 'WARNING Original checksums table is empty. Perhaps checksums never fetched.' );
			mss_utils::update_checksums_web();
		}
		$this->flog( 'INFO Checking updated definitions.' );
		$this->maybe_update_definitions();
		$jobs = $this->create_job_queue();

		if ( count( $jobs ) ) {
			global $wpdb;
			$row_count = $wpdb->get_var( "SELECT COUNT(*) FROM {$this->mss_issues}" );
			// Truncate the table
			$wpdb->query( "TRUNCATE TABLE {$this->mss_issues}" );
		}
		$this->initialize_state( $jobs );
		if ( ! is_null( $row_count ) && $row_count > 0 ) {
			$this->state['truncated_issues'] = $row_count;
		}
		$this->flog( 'INFO Scanner saving state.' );
		// $this->save_state(); // save the state so that we can reference the identifier
		mss_utils::update_setting( 'scan_handshake_key', $this->state['identifier'] );
	}

	/**
	 * Validate if the scan can continue and continue else abort.
	 *
	 * @return void
	 */
	function validate_scan_routines() {
		if ( isset( $_REQUEST['token'] ) ) {
			if ( $this->has_state() ) {
				$state          = mss_utils::get_option( 'scanner_state' );
				$continue_token = isset( $state['continue_token'] ) ? $state['continue_token'] : false;
				if ( $continue_token == $_REQUEST['token'] ) {
					$this->flog( 'INFO: Continue Accepted...' );
					$this->restore_state();
				} else {
					$this->flog( 'ERROR: Continue token does not match. Expected ' );
					$this->fdump( $continue_token );
					$this->flog( ' Received ' );
					$this->fdump( $_REQUEST['token'] );
					$this->flog( ' Aborting.' );
					wp_send_json_error( 'Continue token does not match. Aborting.' );
				}
			} else {
				$this->flog( 'ERROR: No state found. Returning.' );
				wp_send_json_error( 'No state found. Returning.' );
			}
		} else {
			$this->flog( 'ERROR: Continue token not received. Received ' . $_REQUEST['token'] . ' Aborting.' );
			wp_send_json_error( 'Continue token not received. Returning.' );
		}
	}


	/**
	 * Terminate the scan and cleanup
	 *
	 * @return void
	 */
	function term_scan_routines() {
		$this->clear_state();
		mss_utils::delete_setting( 'scan_handshake_key' );
		mss_utils::delete_setting( 'kill_requested' );
		mss_utils::delete_option( 'scanner_state_backup' );
	}

	/**
	 * Creates and returns the job queue
	 *
	 * @return void
	 */
	function create_job_queue() {
		$jobs = array();

		// $jobs['dbmalwarecount']   = array(
		// 'posts'    => array(),
		// 'postmeta' => array(),
		// 'options'  => array(),
		// 'comments' => array(),
		// );
		// $jobs['filemalwarecount'] = '';

		$jobs['dbmalwarescan'] = array(
			'posts'    => array(),
			'postmeta' => array(),
			'options'  => array(),
			'comments' => array(),
		);

		$jobs['filemalwarescan'] = '';

		$filtered_jobs = array_filter(
			$jobs,
			function ( $jobName ) {
				return is_callable(
					array(
						$this,
						'phase_' . $jobName,
					)
				);
			},
			ARRAY_FILTER_USE_KEY
		);

		return $filtered_jobs;
	}

	/**
	 * Triggers the specific job that is on the stack.
	 *
	 * @return void
	 */
	function trigger_job() {
		if ( ! empty( $this->state['jobs'] ) && is_array( $this->state['jobs'] ) && count( $this->state['jobs'] ) ) {
			while ( ! empty( $this->state['jobs'] ) && is_array( $this->state['jobs'] ) && count( $this->state['jobs'] ) ) {
				do_action( 'mss_scan_phase_' . array_keys( $this->state['jobs'] )[0] );
				$this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['end'] = microtime( 1 );
				unset( $this->state['jobs'][ array_keys( $this->state['jobs'] )[0] ] );
			}
		} else {
			$this->flog( 'WARNING ' . __FUNCTION__ . ' found empty jobs' );
		}
	}

	// DB SCAN PHASE AND RELATED FUNCTIONS

	/**
	 * Scans the database;
	 */
	public function phase_dbmalwarescan() {

		/*
		The tables to scan should be populated in advance or while creating the job
		After
		*/

		if ( ! empty( $this->state['jobs']['dbmalwarescan'] ) && is_array( $this->state['jobs']['dbmalwarescan'] ) && count( $this->state['jobs']['dbmalwarescan'] ) ) {

			if ( empty( $this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['items'] ) ) {
				$this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['items']   = 0;
				$this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['start']   = time();
				$this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['message'] = '';
			}

			$tables = $this->state['jobs']['dbmalwarescan'];
			foreach ( $tables as $table => $val ) {
				$this->scan_table( $table );
				unset( $this->state['jobs']['dbmalwarescan'][ $table ] );
			}
		} else {
			// This would throw into an infinite loop so kill the scan
			$this->clear_state();
			$this->flog( 'ERROR ' . __FUNCTION__ . ' failed with state ' . print_r( $this->state, 1 ) . ' Scan killed.' );
		}
	}

	/**
	 * Scans a given WordPress table for malware.
	 *
	 * @param [type] $table limited to 4 specific WordPress tables.
	 * @return void
	 */
	function scan_table( $table ) {
		global $wpdb;

		// Load malware definitions
		$definitions = $this->get_malware_db_definitions();

		if ( isset( $this->state['jobs']['dbmalwarescan'][ $table ] ) ) {

			// Start from the last processed definition or default to 0
			$last_definition_index = isset( $this->state['jobs']['dbmalwarescan'][ $table ]['definition_id'] )
								? $this->state['jobs']['dbmalwarescan'][ $table ]['definition_id']
								: 0;

			$db_table = $wpdb->{$table};
			if ( empty( $db_table ) ) { // If the table isn't set in $wpdb, this returns NULL
				$this->flog( 'ERROR: Invalid table ' . $table . ' provided for scan_db_threats' );
				unset( $this->state['jobs']['dbmalwarescan'][ $table ] );
				return false; // or handle this case as you see fit
			}
			for ( $i = $last_definition_index; $i < count( $definitions ); $i++ ) {
				$this->flog( 'INFO Scanning ' . $table . ' against definition ' . $i . ' of ' . count( $definitions ) . ' definitions.' );
				$this->maybe_save_and_fork();
				$this->state['jobs']['dbmalwarescan'][ $table ]['definition_id'] = $i;
				if ( empty( $this->state['jobs']['dbmalwarescan'][ $table ]['results'] ) ) {
					$where_clause_decoded = $this->decode( $definitions[ $i ]['query'] );
					$query                = '';
					switch ( $table ) {
						case 'posts':
							$query = "SELECT ID FROM $db_table WHERE post_content LIKE '%s'";
							break;
						case 'postmeta':
							$query = "SELECT meta_id AS id FROM $db_table WHERE meta_value LIKE '%s'";
							break;
						case 'options':
							$query = "SELECT option_id AS id FROM $db_table WHERE option_value LIKE '%s'";
							break;
						case 'comments':
							$query = "SELECT comment_ID AS id FROM $db_table WHERE comment_content LIKE '%s' AND comment_approved = '1'";
							break;
						default:
							$this->flog( 'ERROR: Invalid table ' . $table . ' provided for scan_db_threats' );
							return false;
					}

					$query        = $wpdb->prepare( $query, $where_clause_decoded );
					$matching_ids = $wpdb->get_col( $query );

					$this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['items'] += count( $matching_ids );
					$elapsed = ( time() - $this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['start'] );
					if ( $elapsed ) {
						$this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['message'] = 'Scanned ' . $this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['items'] . ' suspicious database records in ' . mss_utils::human_readable_time_diff( $elapsed ) . ' @ ' . ( round( $this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['items'] / $elapsed ) ) . ' records per second…';
					}
				} else {
					$matching_ids = $this->state['jobs']['dbmalwarescan'][ $table ]['results'];
				}

				if ( $matching_ids ) {
					$this->state['jobs']['dbmalwarescan'][ $table ]['results'] = $matching_ids;
				}
				// Ensure 'results' is set before iterating
				if ( isset( $this->state['jobs']['dbmalwarescan'][ $table ]['results'] ) ) {
					foreach ( $this->state['jobs']['dbmalwarescan'][ $table ]['results'] as $key => $id ) {
						$this->maybe_save_and_fork();
						if ( ! empty( $db_table ) ) {
							$this->enqueue_db_scan( $id, $i, $db_table );
						} else {
							$this->flog( 'ERROR: Invalid table ' . $table . ' provided for scan_db_threats' );
							unset( $this->state['jobs']['dbmalwarescan'][ $table ] );
						}
						unset( $this->state['jobs']['dbmalwarescan'][ $table ]['results'][ $key ] );
					}
					// Clear the results after processing
					unset( $this->state['jobs']['dbmalwarescan'][ $table ]['results'] );
				}
				// Move to the next definition
				$this->state['jobs']['dbmalwarescan'][ $table ]['definition_id'] = $i + 1;
			}
			// Clear the posts job from the state after all definitions are processed
			unset( $this->state['jobs']['dbmalwarescan'][ $table ] );
		}
	}

	/**
	 * Scans given database-content against database definitions
	 *
	 * @param [type] $row
	 * @param [type] $table
	 * @return void
	 */
	function enqueue_db_scan( $postid, $def_id, $table ) {
		// need the results as well as the name of the table.
		$this->flog( 'INFO Enqueuing db scan for ' . $postid . ' ' . $def_id . ' ' . $table );
		$data = $this->exor(
			array(
				'id'     => $postid,
				'def_id' => $def_id,
				'table'  => $table,
			)
		);
		$data = $this->encode( $data );
		$url  = admin_url(
			'admin-ajax.php?action=mss_scan_db&marker=' . $data
		);

		$response = $this->scan_request( $url );
		if ( is_wp_error( $response ) ) {
			$this->flog( 'ERROR:  ' . $response->get_error_message() );
			// Handle the error accordingly
		}
	}

	/**
	 * Decode and queue the file for scanning
	 *
	 * @return void
	 */
	function scan_db_callback() {
		$this->flog( 'INFO: ' . __FUNCTION__ . ' received request ' . print_r( $_REQUEST, 1 ) );
		$this->accept_async_handover();

		$sec  = $this->do_scan_handshake();
		$data = $this->decode( $_REQUEST['marker'] );
		$data = $this->dxor( $data, $sec );

		if ( isset( $data['id'] ) && isset( $data['def_id'] ) && isset( $data['table'] ) ) {
			$this->scan_db_threats(
				$data['id'],
				$data['def_id'],
				$data['table'],
				$sec
			);
		} else {
			$this->flog( 'WARNING: something wrong with db data scan request: some data element(s) empty' . print_r( $data, 1 ) . ' ' . $sec . ' ' . print_r( $_REQUEST, 1 ) );
		}
		wp_die(); // this is required to terminate immediately and return a proper response
	}

	/**
	 * Scans a specific database table's column in a specific row for malware
	 *
	 * @param string $row_id
	 * @param string $def_index
	 * @param string $table
	 * @param string $scan_id
	 * @return void
	 */
	function scan_db_threats( $row_id = '', $def_index = '', $table = '', $scan_id = '' ) {
		global $wpdb;

		// Ensure all required parameters are provided
		if ( empty( $row_id ) || empty( $def_index ) || empty( $table ) || empty( $scan_id ) ) {
			$this->flog( 'ERROR: Empty parameters provided for scan_db_threats' );
			return false; // or handle this case as you see fit
		}

		$query = '';

		switch ( $table ) {
			/**
			 * Match case for each $table and accordingly create a $query and a $column to fetch the content from
			 */
			case $wpdb->posts:
				$query = $wpdb->prepare( "SELECT post_content FROM $table WHERE ID = %d", $row_id );
				break;
			case $wpdb->postmeta:
				$query = $wpdb->prepare( "SELECT meta_value FROM $table WHERE meta_id = %d", $row_id );
				break;
			case $wpdb->options:
				$query = $wpdb->prepare( "SELECT option_value FROM $table WHERE option_id = %d", $row_id );
				break;
			case $wpdb->comments:
				$query = $wpdb->prepare( "SELECT comment_content FROM $table WHERE comment_ID = %d", $row_id );
				break;
			default:
				$this->flog( 'ERROR: Invalid table ' . $table . ' provided for scan_db_threats' );
				return false; // or handle this case as you see fit
		}

		// Fetch the content from the specified table and column
		$content = $wpdb->get_var( $query );

		$def               = $this->get_db_sig_by_index( $def_index );
		$infection_details = array();
		if ( ! empty( $content ) && $this->str_size_bytes( $content ) < $this->filemaxsize ) { // could return string, empty or null
			$pattern = $this->decode( $def['signature'] );
			$result  = preg_match_all( $pattern, $content, $found );
			if ( ! empty( $result ) ) {
				if ( in_array( $def['severity'], array( 'severe', 'high' ) ) ) {
					mss_utils::update_setting( 'infected', true );
				}

				$infection_details['type']     = 'database';
				$infection_details['severity'] = $def['severity'];

				$infection_details['infection_id'] = $def['id'];
				$infection_details['pointer']      = $query;

				$infection_details['comment'] = array( 'message' => '<span class="severity ' . $def['severity'] . '">' . $def['severity'] . '</span> infection found in <span class="db_table">' . substr( str_replace( $wpdb->prefix, '', $table ), 0, -1 ) . '<span> ID <span row="row-' . $row_id . '">' . $row_id . '</span>.' );

				$this->insert_issue( $scan_id, $infection_details );
			}
		}
	}

	// FILE SCAN PHASE AND RELATED FUNCTIONS

	/**
	 * Indexes files resursively and executes a malware scan on those files.
	 *
	 * @return void
	 */
	public function phase_filemalwarescan( $passed = array() ) {
		if ( empty( $this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['items'] ) ) {
			$this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['items']   = 0;
			$this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['start']   = time();
			$this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['message'] = '';
		}
		if ( $passed ) {
			// $this->flog( 'INFO: ' . __FUNCTION__ . ' called with passed ' . print_r( $passed, 1 ) );
			// $this->flog( $this->state );
		}
		$dir     = $this->state['dstack'][ count( $this->state['dstack'] ) - 1 ];
		$entries = $this->get_dir_entries( $dir );
		if ( ! isset( $this->state['dcounter'][ $dir ] ) ) {
			$this->flog( 'ERROR: Was looking for ' . $dir . ' inside ' . print_r( $this->state['dcounter'], 1 ) . ' and found nothing.' );
		}
		for ( ;( isset( $this->state['dcounter'][ $dir ] ) ) && $this->state['dcounter'][ $dir ] < count( $entries ); ) {
			$this->maybe_save_and_fork(); // We are about to start a new directory, so may be save the state and attempt to fork the process
			$location = trailingslashit( $dir ) . $entries[ $this->state['dcounter'][ $dir ] ];
			++$this->state['dcounter'][ $dir ];
			if ( $this->is_valid_file( $location ) ) {
				$this->process_file( $location );
				$this->state['size'] = array_key_exists( 'size', $this->state ) ? (int) $this->state['size'] + @filesize( $location ) : @filesize( $location );
				++$this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['items'];
				$elapsed = ( time() - $this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['start'] );
				if ( $elapsed ) {
					$this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['message'] = 'Scanned ' . mss_utils::human_readable_bytes( $this->state['size'] ) . ' in ' . $this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['items'] . ' files in ' . mss_utils::human_readable_time_diff( $elapsed ) . ' @ ' . ( round( $this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['items'] / $elapsed ) ) . ' files per second…<br />Scanning: ' . str_replace( trailingslashit( ABSPATH ), '', $location );
				}
			}
			if ( $this->is_valid_dir( $location ) ) {
				$this->add_dir_to_stack( $location );
				return $this->{__FUNCTION__}( // return else recursion breaks
					array(
						'recursion' => 'yes',
						'caller'    => 'loop',
						'location'  => $location,
					)
				);
				// $this->flog( 'INFO: removing location ' . $location . ' from stack.' );
				// $this->remove_dir_from_stack( $location, $passed );
			}
		}

		$this->flog( 'INFO: removing dir ' . $dir . ' from stack.' );
		$this->remove_dir_from_stack( $dir, $passed );

		if ( count( $this->state['dstack'] )
		// &&
		// $dir !== $this->state['dstack'][ count( $this->state['dstack'] ) - 1 ] &&
		// $this->state['dcounter'][ $this->state['dstack'][ count( $this->state['dstack'] ) - 1 ] ] < count( $this->get_dir_entries( $this->state['dstack'][ count( $this->state['dstack'] ) - 1 ] ) )
		) {
			$this->flog( 'INFO: dstack is not empty. Current dir is ' . $dir . ' and next in stack is ' . $this->state['dstack'][ count( $this->state['dstack'] ) - 1 ] );

			$directory = $this->state['dstack'][ count( $this->state['dstack'] ) - 1 ];
			$entries   = $this->get_dir_entries( $directory );
			$counter   = $this->state['dcounter'][ $directory ];

			$this->flog( 'INFO: ' . 'Counter for ' . $directory . ' is ' . $counter . ' and entry count is ' . count( $entries ) . ' Recursing.' );

			// $this->state['dcounter'][ $dir ] < count($this->get_dir_entries( $this->state['dstack'][ count( $this->state['dstack'] ) - 1 ] ))

			// $this->flog( $this->state );
			$this->{__FUNCTION__}(
				array(
					'recursion'     => 'yes',
					'caller'        => 'stack',
					'location_post' => $directory,
				)
			);
		}
	}

	function get_dir_entries( $dir ) {
		$entries = @scandir( $dir );
		if ( ! is_array( $entries ) ) {
			$entries = array(); // Initialize an empty array @scandir returns false on failure
		}
		$entries = array_diff( $entries, array( '.', '..' ) );
		natcasesort( $entries );
		$entries = array_values( $entries );
		return $entries;
	}

	/**
	 * Remove directory from the stack
	 *
	 * @param [type] $dir
	 * @return void
	 */
	function add_dir_to_stack( $location ) {
		if ( ! in_array( $location, $this->state['dstack'] ) ) {
			$this->flog( 'INFO: adding dir ' . $location . ' to stack.' );
			array_push( $this->state['dstack'], $location ); // Need to have an indexed array so that we can access the last element using count( $array ) - 1 in the loop
			$this->state['dcounter'][ $location ] = 0;
		} else {
			$this->flog( 'WARNING: ' . $location . ' already exists in the stack.' );
		}
	}

	/**
	 * Add directory to the stack
	 *
	 * @param [type] $dir
	 * @return void
	 */
	function remove_dir_from_stack( $dir, $passed = '' ) {
		// $this->flog( 'INFO: removing dir ' . $dir . ' from stack.' );
		// $this->flog( $this->state );

		// Remove the directory from stack
		$this->state['dstack'] = array_filter(
			$this->state['dstack'],
			function ( $value ) use ( $dir ) {
				return $value !== $dir;
			}
		);

		// Remove the directory from counter
		if ( ! isset( $this->state['dcounter'][ $dir ] ) ) {
			$this->flog( 'WARNING Dir ' . $dir . ' not found in dcounter. At least happens when directory has no valid files returned by is_valid_file.' );
		}
		unset( $this->state['dcounter'][ $dir ] );
		// $this->flog( $this->state );
	}

	/**
	 * Request a malware scan of the file via ajax / wp_remote_
	 *
	 * @param [type] $file
	 * @return void
	 */
	function process_file( $file ) {
		if ( ! $this->file_needs_scan( $file ) ) { // First run checks if the file matches or needs a thorough scan
			return;
		}
		$data = $this->exor(
			array(
				'type' => 'file',
				'path' => $file,
			)
		);
		$data = $this->encode( $data );

		$url      = admin_url(
			'admin-ajax.php?action=mss_scan_file&marker=' . $data
		);
		$response = $this->scan_request( $url );
	}

	/**
	 * Check if the file qualifies for scan
	 *
	 * @param [type] $file_path
	 * @return bool
	 */
	function file_needs_scan( $file_path ) {
		global $wpdb;
		$file_path = mss_utils::realpath( $file_path );
		$this->flog( 'INFO Assessing ' . $file_path );
		// return false;
		$checksum = @hash_file( 'sha256', $file_path );
		if ( ! $checksum ) {
			$this->flog( 'WARNING File not accessible ' . $file_path );
			return false;
		}
		$cs_query         = $wpdb->prepare(
			"SELECT 
                file_id, 
                path, 
                checksum, 
                type, 
                ver 
            FROM {$this->mss_origin_cs} 
            WHERE checksum = %s",
			$checksum
		);
		$checksum_matches = $wpdb->get_results( $cs_query, ARRAY_A );

		if ( empty( $checksum_matches ) ) { // no match in original checksums. Either file is non-core or it has been modified

			$gencs_query = $wpdb->prepare(
				"SELECT 
                    path, 
                    checksum, 
                    sid, 
                    type,
                    sver,
                    attrib 
                FROM {$this->mss_gen_cs} 
                WHERE path = %s AND checksum = %s",
				$file_path,
				$checksum
			); // pass path in conditional so that we don't get a match for a different file with the same checksum

			$existing_file_info = $wpdb->get_results( $gencs_query, ARRAY_A );
			if ( empty( $existing_file_info ) ) { // no scan-history for file
				return true;
			} else {
				if ( count( $existing_file_info ) > 1 ) {
					$this->flog( 'WARNING Multiple matches in existing_file_info. Investigate: ' . print_r( $existing_file_info, 1 ) );
				}
				$existing_file_info = array_pop( $existing_file_info ); // first element of the array
				if ( $existing_file_info['sver'] == $this->definitions['v'] ) { // earliest return. If the file has been scanned against the same definitions, skip
					if ( ! empty( $existing_file_info['type'] ) ) { // file has an infection so log it into issues
						$issue = array(
							'type'         => 'file',
							'severity'     => $existing_file_info['type'],
							'infection_id' => $existing_file_info['sid'],
							'pointer'      => $file_path,
							'comment'      => array( 'message' => 'File <span class="filename">' . $file_path . '</span> has <span class="severity ' . $existing_file_info['type'] . '">' . $existing_file_info['type'] . '</span> infection.' ),
						);
						$this->insert_issue(
							$this->state['identifier'],
							$issue
						);
					}
					return false;
				}
				$attrib = ! empty( $existing_file_info['attrib'] ) ? json_decode( $existing_file_info['attrib'], 1 ) : false;
				$mtime  = microtime( 1 );
				// IDEA IS TO RETURN FASTERT I.E AT THE FIRST CHECK

				if ( empty( $existing_file_info['type'] ) || // file doesn't have an infection severity
					empty( $attrib ) || // scan-attributes are missing
					empty( $attrib['sig_hash'] ) || // sig_hash is missing
					empty( $this->definitions['definitions']['files'][ $existing_file_info['sid'] ] ) || // infection id doesn't exists in the current set of signatures
					( ! empty( $this->definitions['definitions']['files'][ $existing_file_info['sid'] ] ) && // signature id exists but...
						(
							$attrib['sig_hash'] !=
							hash( 'sha256', $this->definitions['definitions']['files'][ $existing_file_info['sid'] ]['signature'] ) // doesn't match the signature of that signature-id
						) // signature has changed
					)
				) { // check if this file is infected or not
					return true;
				} else {

					if ( ! empty( $existing_file_info['type'] ) ) { // file has an infection so log it into issues
						$issue = array(
							'type'         => 'file',
							'severity'     => $existing_file_info['type'],
							'infection_id' => $existing_file_info['sid'],
							'pointer'      => $file_path,
							'comment'      => array( 'message' => 'File <span class="filename">' . $file_path . '</span> has <span class="severity ' . $existing_file_info['type'] . '">' . $existing_file_info['type'] . '</span> infection.' ),
						);
						$this->insert_issue(
							$this->state['identifier'],
							$issue
						);
					}

					// the only way to skip the file scan is if the file is infected and the signature hasn't changed
					return false;
				}
			}
		} else { // matches core checksum
			return false;
		}
	}

	/**
	 * Decode and queue the file for scanning
	 *
	 * @return void
	 */
	function scan_file_callback() {
		$this->accept_async_handover();

		$sec  = $this->do_scan_handshake();
		$data = $this->decode( $_REQUEST['marker'] );
		$data = $this->dxor( $data, $sec );

		if ( ! empty( $data['type'] ) && ! empty( $data['path'] ) ) {
			$this->scan_file_threats( $data['path'], $sec );
		} else {
			$this->flog( 'WARNING something wrong with data. ' . 'identifier: ' . $sec . "\t" . print_r( $_REQUEST, 1 ) );

		}
		wp_die(); // this is required to terminate immediately and return a proper response
	}

	/**
	 * Scan the file for malware
	 *
	 * @param [type] $file
	 * @return void
	 */
	function scan_file_threats( $file, $scan_id ) {
		$this->is_valid_file( $file );
		$this->flog( 'INFO Scanning file: ' . $file );
		$file_contents = @file_get_contents( $file );
		$ext           = $this->get_fileext( $file );
		$tests         = array();

		$definitions = $this->get_malware_file_definitions();

		$sver = $this->get_definition_version();
		if ( strpos( @ini_get( 'disable_functions' ), 'ini_set' ) === false ) {
			@ini_set( 'pcre.backtrack_limit', 1000000 );
		}

		foreach ( $definitions as $definition => $signature ) {
			if ( $signature['class'] == 'htaccess' && $ext != 'htaccess' ) {
				continue;
			}

			$matches = false;
			try {
				if ( in_array( $signature['severity'], array( 'severe', 'high' ) ) ) {
					$matches = preg_match( $this->decode( $signature['signature'] ), $file_contents, $found );
				}
			} catch ( Exception $e ) {
				$this->flog( 'WARNING Faulty Signature: ' . $definition );
				$this->flog( 'WARNING Faulty Pattern: ' . $this->decode( $signature['signature'] ) );
				$this->flog( 'WARNING File: ' . $file );
				$this->flog( 'WARNING message: ' . $e->getMessage() );
				continue;
			}
			if ( $matches >= 1 ) {

				if ( in_array( $signature['severity'], array( 'severe', 'high' ) ) ) {
					mss_utils::update_setting( 'infected', true );
				}
				return $this->save_file_status( $scan_id, $file, $definition, $signature, $sver, ); // file, sigid, severity, dver
			}
		}
		return $this->save_file_status( $scan_id, $file, '', '', $sver );
	}

	/**
	 * Attempt to continue the scan if it died somehow
	 *
	 * @return void
	 */
	function attempt_continue_broken() {
		// $this->clear_state();
		// mss_utils::get_setting( 'kill_requested' );
		// mss_utils::delete_option( 'continue_token' );
		// $this->flog('reset complete.');
		// exit( 0 );
		if ( $this->has_state() ) {
			$now       = $_SERVER['REQUEST_TIME'];
			$state     = mss_utils::get_option( 'scanner_state' );
			$started   = $state['start'];
			$remaining = $this->get_cycle_remaining( $started );
			// todo: this should attempt based on max_execution_time instead of a hardcoded 120
			// when should we attempt triggering a continue?
			// if maybe_save_and_fork was supposed to be called but wasn't
			// when is maybe_save_and_fork called? when remaining_time <= time_buffer
			// so if it is beyond that time, we should attempt to continue

			$this->flog( __FUNCTION__ . ' Calc ' . abs( $remaining * ( 22 / 7 ) ) . ' started ' . $started . ' now ' . $now . ' remaining ' . $remaining );
			if ( $remaining <= 1.5 * $this->get_cycle_time() ) { // make sure we don't attempt a restart at the same time.
				$this->flog( 'ERROR ERROR ERROR ' );
				$this->flog( 'WARNING Previous scan exited at: ' . $state['start'] . ' which is ' . date( 'm/d/Y H:i:s', $state['start'] ) . ' attempting to restart because now is ' . $now . ' ' . date( 'm/d/Y H:i:s', $now ) . ' ' . var_export( mss_utils::get_option( 'scanner_state' ), 1 ) );

				$continue_token = microtime( 1 );
				mss_utils::update_option( 'continue_token', $continue_token );
				// unset( $state['locked'] );
				mss_utils::update_option( 'scanner_state', $state );
				$url  = admin_url( 'admin-ajax.php?action=mss_scan_operation&mss_fork=1&operation=continue&force=true&token=' . $continue_token );
				$url  = $this->get_self_url( $url );
				$fork = @wp_remote_get(
					$url,
					array(
						'blocking'  => true,
						'sslverify' => false,
						'headers'   => array(
							'mss_fork' => '1',
							'Host'     => parse_url( site_url(), PHP_URL_HOST ),
						),
					)
				);
				$this->flog( 'ERROR: Had to force fork to resume. ' . $url );
			} else {
				$this->flog( $remaining . ' seconds remaining. Not attempting to continue.' );
				// $this->flog( 'INFO It has only been ' . ( $now - $state['start'] ) . ' seconds since the last scan. Need to wait another ' . ( 120 - ( $now - $state['start'] ) ) . ' seconds. Not continuing.' );
			}
		}
	}

	/**
	 * Checks if we are about to hit max_execution_time and forks the process if we are, using curl / wp_remote_*
	 *
	 * @return void
	 */
	public function maybe_save_and_fork() {
		if ( mss_utils::get_setting( 'kill_requested' ) ) {
			$this->flog( 'WARNING: Kill requested. Aborting ' . $this->state['start'] );
			$this->term_scan_routines();
			exit( 0 );
		} else {
		}
		$max_execution_time = $this->max_execution_time;
		$start              = $this->state['start'];
		$now                = time();
		$elapsed            = $now - $start;
		$remaining_time     = ( $max_execution_time - $elapsed );
		$remaining          = $this->get_cycle_remaining( $start );
		if ( $remaining <= 0 ) {

			$this->flog( 'INFO: Time arrived for continue' );

			$this->update_performance_stats();

			$continue_token                = number_format( microtime( 1 ), 6, '.', '' ); // float to string conversion is not reliable in PHP
			$this->state['continue_token'] = $continue_token;
			$this->save_state();
			$url = 'admin-ajax.php?action=mss_scan_operation&mss_fork=1&operation=continue&token=' . $continue_token;
			$this->flog( 'Orig URL: ' . $url );
			$url = admin_url( $url );
			$this->flog( 'admin_url URL: ' . $url );
			$url = $this->get_self_url( $url );
			// $this->flog( 'INFO ' . str_repeat( "\t\t\t", $this->state['pad'] ) . 'Forking to ' . $url . ' because of remaining_time:' . $remaining_time . ' max_execution_time: ' . $max_execution_time . ' $start:' . $start . ' now:' . $now . ' elapsed: ' . $elapsed );
			$fork = @wp_remote_get(
				$url,
				array(
					'timeout'   => $this->time_buffer - 1,
					'blocking'  => false,
					'sslverify' => false,
					'headers'   => array(
						'mss_fork'   => '1',
						'Host'       => parse_url( site_url(), PHP_URL_HOST ),
						'connection' => 'close',
					),
				)
			);
			$this->flog( 'INFO: Forking to: ' . $url . ' for ' . $this->state['start'] );
			// $this->flog( 'INFO: forking result:' );
			// $this->flog( $fork );
			exit( 0 );
		} // remaining time check complete
		else {
			$this->flog( 'INFO STATE START:' . $this->state['start'] );
		}
	}

	// DB QUERY FUNCTIONS

	/**
	 * Create the database tabled required for the plugin
	 *
	 * @return void
	 */
	function db_install() {
		global $wpdb;

		$plugin_version = mss_utils::get_plugin_data();

		if ( ! empty( $plugin_version['Version'] ) ) {
			$plugin_version = $plugin_version['Version'];
		} else {
			$plugin_version = '1.11';
		}

		$charset_collate = $wpdb->get_charset_collate();

		$mss_origin_cs = "CREATE TABLE IF NOT EXISTS {$this->mss_origin_cs} (
			file_id INT(11) NOT NULL AUTO_INCREMENT,
			path VARCHAR(191) NOT NULL,
			checksum LONGTEXT NOT NULL,
			type LONGTEXT NOT NULL,
			ver LONGTEXT NOT NULL,
			UNIQUE (path),
			PRIMARY KEY  (file_id)
		) $charset_collate;";
		// The PRIMARY KEY keyword must have exactly two spaces between it and the definition of the primary key.

		$mss_gen_cs = "CREATE TABLE IF NOT EXISTS {$this->mss_gen_cs} (
			file_id INT(11) NOT NULL AUTO_INCREMENT,
			path VARCHAR(191) NOT NULL,
			checksum LONGTEXT NOT NULL,
			sid LONGTEXT NOT NULL,
			type LONGTEXT NOT NULL,
			sver LONGTEXT NOT NULL,
			attrib LONGBLOB,
			UNIQUE (path),
			PRIMARY KEY  (file_id)
		) $charset_collate;";
		// The PRIMARY KEY keyword must have exactly two spaces between it and the definition of the primary key.

		$mss_issues = "CREATE TABLE IF NOT EXISTS {$this->mss_issues} (
			issue_id INT(11) NOT NULL AUTO_INCREMENT,
			scan_id LONGTEXT NOT NULL,
			type LONGTEXT NOT NULL,
			severity LONGTEXT NOT NULL,
			details LONGTEXT NOT NULL,
			comment LONGTEXT NOT NULL,
			PRIMARY KEY  (issue_id)
		) $charset_collate;";
		// The PRIMARY KEY keyword must have exactly two spaces between it and the definition of the primary key.

		require_once ABSPATH . 'wp-admin/includes/upgrade.php';
		dbDelta( $mss_origin_cs );
		dbDelta( $mss_gen_cs );
		dbDelta( $mss_issues );
		mss_utils::update_setting( 'db_version', $plugin_version );
	}

	/**
	 * Upgrade tables if required
	 *
	 * @return void
	 */
	function upgrade_tables() {

		$db_version = mss_utils::get_setting( 'db_version' );

		$plugin_version = mss_utils::get_plugin_data();

		if ( ! empty( $plugin_version['Version'] ) ) {
			$plugin_version = $plugin_version['Version'];
		} else {
			$plugin_version = '1.11';
		}

		if ( ! $db_version || version_compare( $db_version, $plugin_version, '<' ) ) {
			$this->db_install();
		}
	}

	/**
	 * Wrapper around various utility functions to fetch checksums
	 * Called by upgrader_process_complete hook
	 */
	function fetch_checksums( $upgrader_object, $options ) {
		$this->flog( 'MSS WARNING!!! Upgrade detected. Slightly COSTLY OPERATION ' . __FUNCTION__ . print_r( $upgrader_object, 1 ) . print_r( $options, 1 ) );

		if ( ! function_exists( 'get_plugin_data' ) ) {
			require_once ABSPATH . 'wp-admin/includes/plugin.php';
		}

		if ( $options['action'] == 'update' && $options['type'] == 'plugin' ) { // Ensure the action is 'update' and type is 'plugin'
			foreach ( $options['plugins'] as $plugin ) {
				$plugin_data = get_plugin_data( trailingslashit( WP_PLUGIN_DIR ) . $plugin );

				mss_utils::update_checksums_plugins( array( $plugin => $plugin_data ) );

				// todo: Delete all checksums for files that no longer exist or are old version
			}
		}
		if ( $options['action'] == 'update' && $options['type'] == 'core' ) {
			// Fetch checksums from the API
			global $wp_version;

			$checksums = mss_utils::update_checksums_core( $wp_version, get_locale() );
			if ( ! $checksums ) { // get_core_checksums failed
				$this->flog( 'WARNING Locale based update failed. Attempting updating core checksums for version ' . $wp_version . ' locale ' . 'en_US' );
				$checksums = mss_utils::update_checksums_core( $wp_version, 'en_US' ); // try en_US locale
				if ( empty( $checksums ) ) {
					$this->flog( 'WARNING en_US checksum update also failed.' );
				}
			}
			// todo: Delete all checksums for files that no longer exist or are old version
		}

		// todo: Add support for theme checksums
	}

	/**
	 * Returns all issues from the issues table
	 *
	 * @return void
	 */
	function get_issues() {
		global $wpdb;

		$query  = 'SELECT * FROM ' . $this->mss_issues;
		$issues = $wpdb->get_results( $query, ARRAY_A );
		return $issues;
	}

	/**
	 * Logs issue to the database
	 *
	 * @param [type]                                       $scan_id
	 * @param [type]                                       $issue('type','severity','infection_id','comment')
	 * @param conditional pointer (file-path or sql query)
	 * @return void
	 */
	function insert_issue( $scan_id, $issue ) {
		global $wpdb;
		$table_name = $this->mss_issues;
		$inserts    = $wpdb->insert(
			$table_name,
			array(
				'scan_id'  => $scan_id,
				'type'     => $issue['type'],
				'severity' => $issue['severity'],
				'details'  => json_encode( $issue ),
				'comment'  => json_encode( $issue['comment'] ),
			),
			array( '%s', '%s', '%s', '%s', '%s' )
		);
	}

	/**
	 * Saves system performance stats to the state
	 *
	 * @return void
	 */
	function update_performance_stats() {
		$this->state['performance']['cpu'] = sys_getloadavg();
		if ( empty( $this->state['performance']['memory'] ) ) {
			$this->state['performance']['memory'] = memory_get_peak_usage( 1 ) / 1024 / 1024;
		} else {
			$current = memory_get_peak_usage( 1 ) / 1024 / 1024;
			if ( $current > $this->state['performance']['memory'] ) {
				$this->state['performance']['memory'] = $current;
			}
		}
		$this->state['job_status'][ array_key_first( $this->state['jobs'] ) ]['elapsed'] = time() - $this->state['job_status'][ array_key_first( $this->state['job_status'] ) ]['start'];
	}

	/**
	 * Save file status into the database
	 *
	 * @param [type] $file: path to file
	 * @param [type] $definition_id: sigid
	 * @param [type] $status: severity
	 * @param [type] $sver: dver
	 * todo: make this more consistent and reusable.
	 * @return void
	 */
	function save_file_status( $scan_id, $file, $sid, $signature, $sver, $attrib = array() ) {
		global $wpdb;

		// Table name
		$table_name = $this->mss_gen_cs;

		$checksum = @hash_file( 'sha256', $file );
		if ( ! $checksum ) {
			$checksum = '';
		}
		$severity = false;
		if ( ! empty( $signature ) ) {
			$attrib['sig_hash'] = hash( 'sha256', $signature['signature'] );
			$severity           = $signature['severity'];

			$infection_details = array();

			$infection_details['type']     = 'file';
			$infection_details['severity'] = $signature['severity'];

			$infection_details['infection_id'] = $sid;
			$infection_details['pointer']      = $file;
			$infection_details['comment']      = array( 'message' => 'File <span class="filename">' . $file . '</span> has <span class="severity ' . $signature['severity'] . '">' . $signature['severity'] . '</span> infection.' );

			unset( $infection_details['signature'] );
			unset( $infection_details['class'] );

			$this->insert_issue(
				$scan_id,
				$infection_details
			);
		}

		$query = $wpdb->prepare( // Prepare the query
			"INSERT INTO $table_name ( path, checksum, sid, type, sver, attrib) VALUES (%s, %s, %s, %s, %s, %s) 
            ON DUPLICATE KEY UPDATE checksum = VALUES(checksum), sid = VALUES(sid), type = VALUES(type), sver = VALUES(sver), attrib = VALUES(attrib)",
			$file,
			$checksum,
			$sid,
			$severity,
			$sver,
			json_encode( $attrib )
		);

		$result = $wpdb->query( $query );       // Execute the query
		return $result;
	}

	/**
	 * Checks if newer definition version is available. If so, update defintiions.
	 *
	 * @return void
	 */
	function maybe_update_definitions() {
		if ( mss_utils::definition_updates_available() ) {
			return mss_utils::update_definitions();
		} else {
		}
	}

	/**
	 * Gets malware definitions for database only
	 *
	 * @return void
	 */
	function get_malware_db_definitions() {
		$defs = mss_utils::get_option_definitions();
		if ( ! empty( $defs['definitions']['db'] ) ) {
			$defs         = $defs['definitions']['db'];
			$indexed_defs = array();
			foreach ( $defs as $key => $value ) {
				$value['id']    = $key; // add the key as 'id' into the sub-array
				$indexed_defs[] = $value;
			}
			return $indexed_defs;
		} else {
			return array();
		}
	}

	/**
	 * Gets malware definitions for files only
	 */
	function get_malware_file_definitions() {
		$defs = $this->get_definitions();
		if ( ! empty( $defs['definitions']['files'] ) ) {
			return $defs['definitions']['files'];
		} else {
			return array();
		}
	}

	/**
	 * Returns the version of the definitions
	 *
	 * @return void
	 */
	function get_definition_version() {
		$definitions = $this->get_definitions();
		if ( $definitions && ! empty( $definitions['v'] ) ) {
			return $definitions['v'];
		}
	}

	/**
	 * Gets the definitions from the database
	 */
	function get_definitions_data() {
		$definitions = $this->get_definitions();
		if ( ! empty( $definitions['definitions'] ) ) {
			return $definitions['definitions'];
		} else {
			return array();
		}
	}

	/**
	 * Gets the definitions from the database
	 */
	function get_definitions() {
		$definitions = mss_utils::get_option_definitions();
		if ( ! empty( $definitions ) ) {
			return $definitions;
		} else {
			return array();
		}
	}

	/**
	 * Returns the indexed malware definitions from the database
	 *
	 * @param [type] $id
	 * @return void
	 */
	function get_db_sig_by_index( $id ) {
		$defs = $this->get_malware_db_definitions();
		if ( ! empty( $defs[ $id ] ) ) {
			return $defs[ $id ];
		} else {
			$this->flog( 'ERROR: get_db_sig_by_index failed for id: ' . $id );
		}
	}

	// STATE HANDLING FUNCTIONS

	/**
	 * Checks if the scanner has a state saved in the db. If so a scan is in progress
	 *
	 * @return boolean
	 */
	function has_state() {
		return ! empty( mss_utils::get_option( 'scanner_state' ) );
	}

	/**
	 * Returns the state of the indexing process
	 *
	 * @return void
	 */
	function initialize_state( $jobs ) {
		$state = array(
			'jobs'        => array(),
			'total'       => 0,
			// 'indexed'     => array(),
			// 'locked'      => microtime( 1 ),
			'dstack'      => array(),
			'dcounter'    => array(),
			'identifier'  => microtime( 1 ),
			'pad'         => 0,
			'recurring'   => 0,
			'start'       => $_SERVER['REQUEST_TIME'], // used to track max_execution_time
			'performance' => array(
				// 'max_memory' => 0, 'max_cpu' => 0, 'max_time' => 0, 'max_files' => 0, 'max_rate' => 0, 'max_rate_file' => '' // suggested by copilot
				'memory_limit' => @ini_get( 'memory_limit' ),
			),
		);

		if ( mss_utils::get_setting( 'supports_localhost' ) ) {
			$state['host'] = mss_utils::get_host();
		} else {
			$state['host'] = false;
		}

		$state['jobs']       = $jobs;
		$state['job_status'] = array_fill_keys( array_keys( $jobs ), array() );
		$this->state         = $state;
		$this->add_dir_to_stack( $this->os_entry_dir );
		// $this->add_dir_to_stack( '/_extvol_data/html/dev/plugindev/wp/wp-includes' );
	}

	/**
	 * Saves the state of indexing
	 *
	 * @return void
	 */
	private function save_state() {
		if ( empty( $this->state ) ) {
			$this->flog( 'ERROR: Attempting to save empty state.' );
		}
		mss_utils::update_option( 'scanner_state', $this->state );
	}

	/**
	 * Backsup the state of scanning
	 *
	 * @return void
	 */
	private function backup_state() {
		if ( empty( $this->state ) ) {
			$this->flog( 'ERROR: Attempting to save empty state.' );
		}
		mss_utils::update_option( 'scanner_state_backup', $this->state );
	}

	/**
	 * Restores the state of scanning
	 *
	 * @return void
	 */
	function restore_state() {
		$this->flog( __FUNCTION__ );
		$state          = mss_utils::get_option( 'scanner_state' );
		$state['start'] = $_SERVER['REQUEST_TIME'];
		$this->flog( 'started TIME: ' . $state['start'] );

		// This sequence is important else backup will save an empty state.
		$this->state = $state; // Restore the state.
		$this->backup_state(); // Back it up for attempting continue just in case.

		$this->clear_state(); // clear the state so that no other request can restore it again
	}

	/**
	 * Clears the state of scanning
	 */
	private function clear_state() {
		$this->flog( 'INFO ' . print_r( $this->state, 1 ) );
		$identifier = false;
		if ( ! empty( $this->state['identifier'] ) ) {
			$identifier = $this->state['identifier']; // save the identifier for later

		}
		mss_utils::delete_option( 'scanner_state' );

		if ( ! $identifier ) {
			$this->flog( 'ERROR No identifier found.' );
			return;
		}

		$time_diff = mss_utils::human_readable_time_diff( explode( '.', $identifier )[0], time() );
		$user      = mss_utils::get_setting( 'api-credentials' );
		$subject   = '';
		$message   = '';

		if ( mss_utils::get_setting( 'kill_requested' ) ) {
			$subject = 'Malcure Security Suite: Scan Cancelled on ' . site_url() . ' after ' . $time_diff;
			$message = '<p>Hi ' . ucfirst( strtolower( $user['first_name'] ) ) . ',</p><p>Malcure Security Suite scan on ' . site_url() . ' was cancelled after ' . $time_diff . '.</p><p>To see the issues detected during the scan, please visit <a href="' . wp_login_url( admin_url( 'admin.php?page=' . MSS_SLUG ) ) . '">' . get_bloginfo( 'name' ) . '</a>.</p><p>Stay awesome!<br/>&mdash;Your Lovely WordPress Website<br />Find me at: ' . site_url() . '</p>';
		} else {
			$subject = 'Malcure Security Suite: Scan Completed on ' . site_url() . ' in ' . $time_diff;
			$message = '<p>Hi ' . ucfirst( strtolower( $user['first_name'] ) ) . ',</p><p>Malcure Security Suite scan on ' . site_url() . ' successfuly completed in ' . $time_diff . '.</p><p>To see the issues detected during the scan, please visit <a href="' . wp_login_url( admin_url( 'admin.php?page=' . MSS_SLUG ) ) . '">' . get_bloginfo( 'name' ) . '</a>.</p><p>Stay awesome!<br/>&mdash;Your Lovely WordPress Website<br />Find me at: ' . site_url() . '</p>';
		}
		if ( ! defined( 'WP_DEBUG' ) || ! WP_DEBUG ) {

			add_filter( 'wp_mail_content_type', array( $this, 'set_mail_content_type' ) );
			@wp_mail( $user['user_email'], $subject, $message );
			remove_filter( 'wp_mail_content_type', array( $this, 'set_mail_content_type' ) );
		}
	}

	// UTILITY FUNCTIONS

	function do_scan_handshake() {
		$scan_handshake_key = mss_utils::get_setting( 'scan_handshake_key' );
		if ( empty( $scan_handshake_key ) ) {
			$this->flog( 'ERROR Identifier is empty. Skipping.' );
			wp_die();
		}
		return $scan_handshake_key;
	}

	function accept_async_handover() {
		if ( ! wp_doing_ajax() ) {
			wp_die();
		}
		@ignore_user_abort( 1 );
		if ( ! headers_sent() ) {
			header( 'Connection: close' );
			header( 'Content-Length: 0' );
			header( 'X-Robots-Tag: noindex' );

		}
		// Turn off output buffering to prevent hanging the script
		while ( ob_get_level() > 0 ) {
			ob_end_clean();
		}

		// Flush system output buffer
		flush();

		// Close the session to unlock the session file
		session_write_close();
	}

	/**
	 * Takes a string as input and returns the number of bytes in the string
	 */
	function str_size_bytes( $str ) {
		// Use wordwrap to break the string into bytes
		$bytesArray = wordwrap( $str, 1, "\n", true );
		// Count the bytes
		$byteCount = substr_count( $bytesArray, "\n" ) + 1;
		return $byteCount;
	}

	// Function to create a nonce
	function create_mss_nonce( $action = '' ) {
		// Create the nonce using the action and the WordPress salt.
		$value = array(
			'action' => $action,
			'stamp'  => microtime( 1 ),
		);

		// Save this setting so that we can verify it later
		mss_utils::update_setting( 'mss_ajax_handshake', $value );
		$nonce = hash_hmac( 'sha256', $value['action'], $value['stamp'] );

		return $nonce;
	}

	// Function to verify a nonce
	function verify_mss_nonce( $nonce, $action = '' ) {
		// Retrieve the saved mss_ajax_handshake value
		$saved_handshake = mss_utils::get_setting( 'mss_ajax_handshake' );

		// Check if the saved mss_ajax_handshake is valid
		if ( ! isset( $saved_handshake['action'] ) || ! isset( $saved_handshake['stamp'] ) ) {
			return false;
		}

		// Check if the action matches
		if ( $saved_handshake['action'] !== $action ) {
			return false;
		}

		// Recompute the nonce
		$expected_nonce = hash_hmac( 'sha256', $saved_handshake['action'], $saved_handshake['stamp'] );

		// Compare the provided nonce to the expected nonce
		if ( hash_equals( $expected_nonce, $nonce ) && ( microtime( 1 ) - $saved_handshake['stamp'] ) < 30 ) {
			mss_utils::delete_setting( 'mss_ajax_handshake' );
			return true;
		}
		return false;
	}

	/**
	 * Sets the content-type header for wp_mail
	 *
	 * @return void
	 */
	function set_mail_content_type() {
		return 'text/html';
	}

	/**
	 * Returns the file extension
	 */
	function get_fileext( $filename ) {
		$nameparts = explode( '.', ".$filename" );
		return strtolower( $nameparts[ ( count( $nameparts ) - 1 ) ] );
	}

	/**
	 * Checks if the table is empty. Used to test if initial checksums need to be fetched
	 *
	 * @param [type] $table_name
	 * @return boolean
	 */
	function is_table_empty( $table_name ) {
		global $wpdb;
		$table_name = sanitize_text_field( $table_name ); // Sanitize the table name to ensure it's a valid SQL identifier
		$count      = $wpdb->get_var( "SELECT COUNT(*) FROM $table_name" ); // Query to count the number of rows in the table
		return $count == 0; // Check if the count is zero
	}

	/**
	 * Wastes a specific number of seconds that speep and usleep fail to waste.
	 *
	 * @param [type] $seconds
	 * @return void
	 */
	function waste_time( $seconds ) {
		$start_time = time();

		$this->number = 1.61803398874989484820458683436563811772030917980576286213544862270526046281890;
		while ( true ) {
			$elapsed_time   = time() - $start_time;
			$remaining_time = $this->max_execution_time - $elapsed_time;
			$remaining_time = $this->max_execution_time - $elapsed_time;
			if ( $remaining_time <= $seconds || $remaining_time <= $this->time_buffer ) {
				break;
			}
			$this->number = $this->number * ( 1 + sqrt( 5 ) ) / 2; // Get the prime factors of the current number
		}
	}

	/**
	 * Dummy encryption for the data so that it doesn't render in plaintext formats in URLs and logs.
	 *
	 * @param [type] $data
	 * @return void
	 */
	function exor( $data ) {
		if ( empty( $this->state['identifier'] ) ) {
			$this->flog( 'ERROR encryption identifier is empty.' );
			return false;
		}
		$key    = (string) $this->state['identifier'];
		$data   = json_encode( $data );
		$output = '';
		for ( $i = 0; $i <
		strlen( $data ); $i++ ) {
			$output .= $data[ $i ] ^
			$key[ $i %
			strlen( $key ) ];
		}
		return urlencode( base64_encode( $output ) );
	}

	/**
	 * Dummy decryption for the data which don't want to render in plaintext formats in URLs and logs.
	 *
	 * @param [type] $data
	 * @param [type] $key
	 * @return void
	 */
	function dxor( $data, $key ) {
		$key  = (string) $key;
		$data = base64_decode( urldecode( $data ) );
		if ( empty( $data ) ) {
			return false; // base64_decode returns false in case of failure
		}
		$output = '';
		for ( $i = 0; $i < strlen( $data ); $i++ ) {
			$output .= $data[ $i ] ^
			$key[ $i %
				strlen( $key ) ];
		}
		$data = json_decode( $output, true );
		if ( empty( $data ) ) {
			return false; // json_decode returns null in case of failure
		}
		return $data;
	}

	/**
	 * Checks if a directory is valid and can be scanned
	 */
	function is_valid_dir( $dir ) {

		if (
				( is_dir( $dir ) && ! is_link( $dir ) && is_readable( $dir ) ) && // 1
				(
					! file_exists( trailingslashit( $dir ) . '.mcignore' ) ||
					$dir == untrailingslashit( ABSPATH )
				)
			) {
			// if ( strpos( $dir, 'wp-admin' ) === false && strpos( $dir, 'wp-includes' ) === false ) { // only scan this dir
			// return false;
			// }
			return true;
		}
	}

	/**
	 * Checks if a file is valid and can be scanned
	 *
	 * @param [type] $file
	 * @return void
	 */
	function is_valid_file( $file ) {
		if ( is_file( $file ) && ! is_link( $file ) && is_readable( $file ) && filesize( $file ) && filesize( $file ) < $this->filemaxsize ) {

			// if ( strpos( $file, '3_high' ) === false ) { // strpos === false means string not found in file path
			// return false;
			// }
			return true;
		}
	}

	/**
	 * Logging function for debugging that utilizes var_dump
	 *
	 * @param [type] $obj
	 * @return void
	 */
	function get_dump( $obj ) {
		ob_start();
		var_dump( $obj );
		$result = ob_get_clean();
		return $result;
	}

	function encode( $str ) {
		return strtr( base64_encode( json_encode( $str ) ), '+/=', '-_,' );
	}

	function decode( $str ) {
		return json_decode( base64_decode( strtr( $str, '-_,', '+/=' ) ), true );
	}

	/*
	function verify_user_token() {
		$user_token = mss_utils::get_setting( 'user_token' );

		if ( ! empty( $user_token ) ) {
			mss_utils::delete_setting( 'user_token' );
		}

		if ( empty( $user_token ) || empty( $_REQUEST['user_token'] ) || $_REQUEST['user_token'] != md5( $user_token ) || ( $now - $user_token ) > $this->max_execution_time ) {
			$this->flog( 'ERROR User token does not match. Aborting.' );
			exit;
			// wp_send_json_error( 'User token does not match.' );
		}
	}


	//Returns all infected files from the database regardless of the running scan state
	function get_file_status( $status = '' ) {
		global $wpdb;
		$table_name = $this->mss_gen_cs;
		$query      = false;
		if ( empty( $status ) ) { // If status is empty, return all files where type is not empty
			$query = $wpdb->prepare( "SELECT * FROM $table_name WHERE type <> %s", $status );
		} else { // If status is empty, return  files which have the requisite status
			$query = $wpdb->prepare( "SELECT * FROM $table_name WHERE type = %s", $status );
		}
		$results = $wpdb->get_results( $query, ARRAY_A );
		return $results;
	}
	function heartbeat_callback( array $response, array $data ) {
		// If we didn't receive our data, don't send any back.
		if ( empty( $data['mss_ping'] ) ) {
			return $response;
		}

		// Calculate our data and pass it back. For this example, we'll hash it.
		$mss_ping = $data['mss_ping'];

		switch ( $mss_ping ) {
			case 'pong':
				if ( $this->has_state() ) {
					$this->attempt_continue_broken();
					$response['mss_running'] = true;
				} else {
					$response['mss_running'] = false;
				}
				break;
			default:
				break;
		}

		return $response;
	}
	function custom_heartbeat_settings( $settings ) {
		$settings['interval'] = $this->max_execution_time / 3; // Interval in seconds
		return $settings;
	}
	*/

	/**
	 * Returns true if the cycle time has exceeded since the given timestamp
	 *
	 * @param [type] $time
	 * @return void
	 */
	function cycle_exceeded_since( $time ) {
		$now        = time();
		$elapsed    = $now - $time;
		$cycle_time = $this->get_cycle_time();
		// $this->flog( '$cycle_time is ' . $cycle_time . ' and $elapsed is ' . $elapsed );
		if ( $elapsed > $cycle_time ) {
			return true;
		}
		return false;
	}

	/**
	 * Gets the remaining time for the current cycle
	 *
	 * @param [type] $since
	 * @return void
	 */
	function get_cycle_remaining( $since ) {
		$now        = time();
		$elapsed    = $now - $since;
		$cycle_time = $this->get_cycle_time(); // ( $this->max_execution_time - $elapsed );
		$remaining  = $cycle_time - $elapsed;
		$this->flog( '$cycle_time is ' . $cycle_time . ' and $elapsed is ' . $elapsed . ' and $remaining is ' . $remaining );
		return $remaining;
	}

	/**
	 * Returns the time allowed for a single cycle run
	 *
	 * @return void
	 */
	function get_cycle_time() {
		return $this->max_execution_time - $this->time_buffer;
	}

	/**
	 * Replace the host with localhost
	 *
	 * @param [type] $url
	 * @return void
	 */
	function get_self_url( $url ) {
		return mss_utils::get_self_url( $url );
	}

	function curl_opts( $handle, $r, $url ) {
		curl_setopt( $handle, CURLOPT_TIMEOUT_MS, 10 );
		// curl_setopt( $handle, CURLOPT_TIMEOUT, $timeout );
		// curl_setopt( $handle, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V4 );
		return $handle;
	}

	function http_api_debug( $response, $context, $class, $parsed_args, $url ) {
		$this->flog( '$response' );
		$this->flog( $response );
		$this->flog( '$context' );
		$this->flog( $context );
		$this->flog( '$class' );
		$this->flog( $class );
		$this->flog( '$parsed_args' );
		$this->flog( $parsed_args );
		$this->flog( '$url' );
		$this->flog( $url );
		return $response;
	}

	function scan_request( $url ) {
		$startTime = microtime( 1 );
		if ( ! empty( $this->state['host'] ) ) {
			$url = str_replace( parse_url( $url, PHP_URL_HOST ), $this->state['host'] . ':' . $_SERVER['SERVER_PORT'], $url );
			add_filter( 'http_api_curl', array( $this, 'curl_opts' ), 10, 3 );
			// add_action( 'http_api_debug', array( $this, 'http_api_debug' ), 11, 5 );
		}
		$response = wp_remote_get(
			$url,
			array(
				'timeout'   => 0.01,
				'blocking'  => false,
				'sslverify' => false,
				'headers'   => array(
					'mss_scan' => '1',
					'Host'     => parse_url( site_url(), PHP_URL_HOST ),
				),
			)
		);
		if ( ! empty( $this->state['host'] ) ) {
			remove_filter( 'http_api_curl', array( $this, 'curl_opts' ), 10, 3 );
			// remove_action( 'http_api_debug', array( $this, 'http_api_debug' ), 11, 5 );
		}
		$endTime     = microtime( 1 );
		$elapsedTime = $endTime - $startTime;
		$this->flog( 'Request time: ' . $elapsedTime . ' seconds' );
		return $response;
	}

	/**
	 * Test function for malware match in custom file
	 *
	 * @return void
	 */
	function custom_match() {
		$file          = '/_extvol_data/html/dev/plugindev/wp/h.txt';
		$file_contents = file_get_contents( $file );
		$definition    = $this->get_definitions_data();
		$definition    = $definition['files']['ZOA6CL'];
		$signature     = $this->decode( $definition['signature'] );
		print_r( $signature );
		$matches = preg_match( $signature, $file_contents, $found );

		mss_utils::llog( $matches );
		mss_utils::llog( $found );
	}

	/**
	 * Logging function for debugging that utilizes print_r
	 *
	 * @param [type] $str
	 * @return void
	 */
	function flog( $str ) {
		mss_utils::flog( $str );
		return true;
	}

	function fdump( $str ) {
		mss_utils::fdump( $str );
		return true;
	}

	function debug( $file = '' ) {
		if ( preg_match( '/1\.txt/', $file ) ) {
			return true;
		}
	}
}

Malcure_Malware_Scanner::get_instance();
