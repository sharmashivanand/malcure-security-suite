<?php
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Singleton Class for WordPress File Indexer
 */
final class Malcure_Malware_Scanner {
	private static $instance    = null;
	private $state              = false;
	private $pad                = 0;
	private $tablename          = '';
	private $max_execution_time = false;
	private $os_entry_dir       = false;


	public $filemaxsize = 1111111;

	private function __construct() {
	}

	public static function get_instance() {
		if ( self::$instance === null ) {
			self::$instance = new self();
			self::$instance->init();
		}
		return self::$instance;
	}

	/**
	 * Initializes hooks and filters
	 *
	 * @return void
	 */
	function init() {
		ini_set( 'max_execution_time', 4 );
		// ini_set( 'error_log', '/var/www/html/dev/plugindev/wp/wp-content/plugins/malcure-security-suite/log.log' );

		$this->max_execution_time = ini_get( 'max_execution_time' ); // Get the max_execution_time
		$backtrackLimit           = ini_get( 'pcre.backtrack_limit' );
		if ( is_numeric( $backtrackLimit ) ) {

			$backtrackLimit = (int) $backtrackLimit;
			if ( $backtrackLimit > 1000000 ) {
				ini_set( 'pcre.backtrack_limit', 1000000 );
				ini_set( 'pcre.recursion_limit', 1000000 );
			}
		}

		$this->scannertablename  = $GLOBALS['wpdb']->prefix . 'mss_files';
		$this->checksumtablename = $GLOBALS['wpdb']->prefix . 'mss_checksums';
		$this->os_entry_dir      = '/_extvol_data/html/dev/plugindev/wp/mss_rec_test';

		add_action( 'Malcure_security_suite_add_meta_boxes', array( $this, 'add_meta_boxes' ), 8 );

		add_action( 'wp_ajax_nopriv_mss_start_scan', array( $this, 'start_scanning' ) );
		add_action( 'wp_ajax_mss_start_scan', array( $this, 'start_scanning' ) );

		add_action( 'wp_ajax_nopriv_mss_scan_file', array( $this, 'scan_file' ) );
		add_action( 'wp_ajax_mss_scan_file', array( $this, 'scan_file' ) );

		add_action( 'mss_plugin_activation', array( $this, 'db_install' ) );
		add_action( 'plugins_loaded', array( $this, 'upgrade_tables' ) );
	}

	/**
	 * Create the database tabled required for the plugin
	 *
	 * @return void
	 */
	function db_install() {
		global $wpdb;
		$table_mss_checksums = $wpdb->prefix . 'mss_checksums';
		$charset_collate     = $wpdb->get_charset_collate();

		$mss_files     = "CREATE TABLE IF NOT EXISTS $this->scannertablename (
            file_id INT(11) NOT NULL AUTO_INCREMENT,
            path LONGTEXT NOT NULL UNIQUE,
            checksum LONGTEXT NOT NULL,
            status LONGTEXT NOT NULL,
            type LONGTEXT NOT NULL,
            sver LONGTEXT NOT NULL,
            attrib LONGBLOB,
            PRIMARY KEY (file_id)
        ) $charset_collate;";
		$mss_checksums = "CREATE TABLE IF NOT EXISTS $this->checksumtablename (
            file_id INT(11) NOT NULL AUTO_INCREMENT,
            path LONGTEXT NOT NULL UNIQUE,
            checksum LONGTEXT NOT NULL,
            type LONGTEXT NOT NULL,
            ver LONGTEXT NOT NULL,
            PRIMARY KEY (file_id)
        ) $charset_collate;";

		require_once ABSPATH . 'wp-admin/includes/upgrade.php';
		dbDelta( $mss_checksums );
		dbDelta( $mss_files );
		mss_utils::update_setting( 'db_version', '1.0' );
	}

	/**
	 * Upgrade tables if required
	 *
	 * @return void
	 */
	function upgrade_tables() {
		// $this->db_install();
		$db_version = mss_utils::get_setting( 'db_version' );

		if ( ! $db_version || version_compare( $db_version, '1.0', '<' ) ) {
			$this->db_install();
		}
	}

	/**
	 * Adds a meta_box to admin UI for scanner
	 *
	 * @return void
	 */
	function add_meta_boxes() {
		// $this->flog( __FUNCTION__ );
		add_meta_box( 'mss_scanner', 'Malware Scanner', array( $this, 'scanner_meta_box' ), $GLOBALS['Malcure_security_suite']['pagehook'], 'main' );
	}

	/**
	 * meta_box callback that renders the admin UI for scanner
	 *
	 * @return void
	 */
	function scanner_meta_box() {
		// $this->flog( __FUNCTION__ );
		echo '<input class="mss_action" value="Click" id="mss_scan_btn" type="submit" />';
		echo '<pre>' . print_r( get_option( 'file_indexed_files' ), 1 ) . '</pre>';

		?>
		<script type="text/javascript">
			jQuery(document).ready(function($){
				$('#mss_scan_btn').click(function(){
					console.log('Initiating Scan');
					mss_start_scan = {
						mss_start_scan_nonce: '<?php echo wp_create_nonce( 'mss_start_scan' ); ?>',
						action: "mss_start_scan",
					};
					$.ajax({
						url: ajaxurl,
						method: 'POST',
						data: mss_start_scan,
						success: function(data, textStatus, jqXHR) {
							console.dir('success Data Begins');
							console.dir(data);
							console.dir(textStatus);
							console.dir(jqXHR);
							console.dir('success Data Ends');
							mss_status_updater = setTimeout(mss_update_scan_status,1000);
						},
						error: function( jqXHR, textStatus, errorThrown){},
						complete: function(jqXHR_data, textStatus) {
							console.log('This page needs to reload to watch progress.')
						},
					});
				});
			});
		</script>
		<?php
	}

	/**
	 * Returns the state of the indexing process
	 *
	 * @return void
	 */
	function get_state() {
		$defaults = array(
			'indexed_files'      => array(),
			'indexed_count'      => 0,
			'stack'              => array(
				$this->os_entry_dir => array( 'counter' => 0 ),
			),
			'current_directory'  => $this->os_entry_dir,
			'previous_directory' => array(),
			'identifier'         => uniqid( 'mss_', true ),
		);

		return wp_parse_args( $this->state, $defaults );
	}

	/**
	 * Saves the state of indexing
	 *
	 * @return void
	 */
	private function save_state() {
		mss_utils::update_option( 'file_indexer_state', $this->state );
		// $this->flog( __FUNCTION__ );
		// $file_path = trailingslashit( __DIR__ ) . 'state.txt'; // Replace with the desired file path
		// file_put_contents( $file_path, serialize( $this->state ) );
	}

	/**
	 * Clears the state of indexing
	 */
	private function clear_state() {
		mss_utils::delete_option( 'file_indexer_state', $this->state );
	}

	/**
	 * Resumes the state of indexing
	 */
	private function attempt_state_restore() {
		$state = mss_utils::get_option( 'file_indexer_state' );
		if ( $state ) {
			if ( $state && is_array( $state ) ) {
				$state = array_filter( $state );
				if ( ! empty( $state ) ) {
					$this->state = $state;
				}
			}
		}
	}

	public function start_scanning() {
		if ( ! empty( $_REQUEST['mss_fork'] ) ) {
			$this->flog( 'Fork initiated' );
		}
		if ( ! wp_doing_ajax() ) {
			$this->flog( '! wp_doing_ajax' );
			wp_die();
		}
		// return;
		session_write_close();
		ignore_user_abort( 1 );

		// $this->flog( __FUNCTION__ );
		$this->attempt_state_restore();
		if ( $this->state ) {
			$this->flog( 'Found previous state.' );
			// $this->flog( $this->state );
		} else {
			$this->flog( 'Creating state.' );
			$this->state = array(
				'indexed_files'      => array(),
				'indexed_count'      => 0,
				'stack'              => array(
					$this->os_entry_dir => array( 'counter' => 0 ),
				),
				'current_directory'  => $this->os_entry_dir,
				'previous_directory' => array(),
				'identifier'         => uniqid( 'mss_', true ),
			);
			// $this->flog( $this->state );
			$this->save_state(); // save the state so that we can reference the identifier
		}
		$this->index_files_recursively();
		$this->flog( 'Final state before clearing' );
		unset( $this->state['logged'] );
		$this->flog( $this->state );
		$this->clear_state();
		wp_die();
	}

	/**
	 * Indexes files resursively
	 *
	 * @return void
	 */
	public function index_files_recursively() {
		if ( strpos( mss_utils::realpath( $this->state['current_directory'] ), mss_utils::realpath( ABSPATH ) ) === false ) {
			$this->flog( 'Exiting because of strpos because current directory ' . $this->state['current_directory'] . ' breaches OS. ABSPATH is: ' . ABSPATH );
			return;
		}
		if ( $this->valid_dir( $this->state['current_directory'] ) ) {
			$entries = @scandir( $this->state['current_directory'] );
			if ( is_array( $entries ) ) {
				$entries = array_diff( $entries, array( '.', '..' ) );
				natcasesort( $entries ); // sort case insensitive "natural order" algorithm
				$entries = array_values( $entries ); // reset indices so that they start with 0

				// if ( ! count( $entries ) ) {
				// $this->flog( 'Exiting because of empty entries in: ' . $this->state['current_directory'] );
				// return;
				// }
				// $this->flog( str_repeat( "\t\t\t", $this->pad ) . 'Directory    : ' . $this->state['current_directory'] );
				// $this->flog( str_repeat( "\t\t\t", $this->pad ) . 'entry Counter: ' . count( $entries ) );
				if ( empty( $this->state['logged'][ $this->state['current_directory'] ] ) ) { // && $this->state['current_directory'] == $this->os_entry_dir
					$this->flog( str_repeat( "\t\t\t", $this->pad ) . 'entries: ' . print_r( implode( ',', $entries ), 1 ) );
					$this->state['logged'][ $this->state['current_directory'] ] = true;
				}

				for ( $i = $this->state['stack'][ $this->state['current_directory'] ]['counter']; $i < count( $entries ); $i++ ) {
					$this->maybe_save_and_fork(); // We are about to start a new directory, so may be save the state and attempt to fork the process
					// $this->flog( str_repeat( "\t\t\t", $this->pad ) . '$this->state' );
					// $this->flog( str_repeat( "\t\t\t", $this->pad ) . json_encode($this->state) );
					$full_path = trailingslashit( $this->state['current_directory'] ) . $entries[ $this->state['stack'][ $this->state['current_directory'] ]['counter'] ];
					// $this->flog($full_path);
					$this->state['stack'][ $this->state['current_directory'] ]['counter']++;
					if ( $this->valid_file( $full_path ) ) {
						$this->state['indexed_files'][] = $full_path;
						$this->state['indexed_count']++;
						$this->request_file_scan( $full_path );
					} elseif ( $this->valid_dir( $full_path ) ) {
						$this->pad++;
						$this->flog( str_repeat( "\t\t\t", $this->pad ) . 'Saving ' . $this->state['current_directory'] . ' at ' . $this->state['stack'][ $this->state['current_directory'] ]['counter'] . ' and entering into ' . $full_path );
						array_push( $this->state['previous_directory'], $this->state['current_directory'] ); // Add the directory to the stack
						$this->state['current_directory']   = $full_path; // Set the current directory
						$this->state['stack'][ $full_path ] = array( 'counter' => 0 ); // Add the directory to the stack
						$this->index_files_recursively();
						$prev_dir = array_pop( $this->state['previous_directory'] );
						$this->flog( str_repeat( "\t\t\t", $this->pad ) . 'Restored current directory to ' . $prev_dir . ' at: ' . $this->state['stack'][ $prev_dir ]['counter'] );
						$this->pad--;
						$this->state['current_directory'] = $prev_dir;
					} else {
						$this->flog( str_repeat( "\t\t\t", $this->pad ) . 'Invalid file or directory: ' . $full_path );
					}
				}

				// $this->flog( 'No more entries in: ' . $this->state['current_directory'] );
				if ( $this->state['stack'][ $this->state['current_directory'] ]['counter'] != count( $entries ) ) {
					$this->flog( '======== Counter: ' . $this->state['stack'][ $this->state['current_directory'] ]['counter'] . ' != ' . count( $entries ) . '========' );
				}
				$this->flog( str_repeat( "\t\t\t", $this->pad ) . 'Indexed ' . $this->state['stack'][ $this->state['current_directory'] ]['counter'] . ' of ' . count( $entries ) . ' entries inside ' . $this->state['current_directory'] );
				unset( $this->state['stack'][ $this->state['current_directory'] ] );
			} else {
				$this->flog( 'Failed to scan: ' . $this->state['current_directory'] );
			}
		} else {
			$this->flog( 'Exiting because of ! valid_dir: ' . $this->state['current_directory'] );
		}
	}

	/**
	 * Checks if we are about to hit max_execution_time and forks the process if we are, using curl / wp_remote_*
	 *
	 * @return void
	 */
	public function maybe_save_and_fork() {
		// $this->quit();
		$max_execution_time = $this->max_execution_time; // ini_get( 'max_execution_time' ); // Get the max_execution_time
		$start              = $_SERVER['REQUEST_TIME'];
		$now                = time();
		$elapsed            = $now - $start;
		$remaining_time     = ( $max_execution_time - $elapsed );
		// $this->flog( '$elapsed:' . $elapsed . ' $remaining_time:' . $remaining_time );

		if ( $remaining_time <= 2 ) { // If there are 2 seconds or less remaining, save the data and exit
			// $this->flog( __FUNCTION__ );

			$this->save_state();
			$url = admin_url( 'admin-ajax.php?action=mss_start_scan&mss_fork=1' );
			$this->flog( 'Forking to ' . $url . ' because of remaining_time:' . $remaining_time . ' max_execution_time: ' . $max_execution_time . ' $start:' . $start . ' now:' . $now . ' elapsed: ' . $elapsed );
			$fork = @wp_remote_get(
				$url,
				array(
					'timeout'   => 0.01,
					'blocking'  => false,
					'sslverify' => false,
					'headers'   => array(
						'mss_fork' => '1',
					),
				)
			);
			// $this->flog( $fork );
			// error_log( 'Exiting because of remaining_time:' . $remaining_time );
			exit( 0 );
			// wp_die();
		} else {
		}
	}

	function waste_time( $seconds ) {
		$start_time = microtime(true);
        $number = 99999989;
		while (true) {
            $elapsed_time = microtime(true) - $start_time;
            $remaining_time = $this->max_execution_time - $elapsed_time;
        
            if ($remaining_time <= $seconds) {
                break;
            }
        
            // Get the prime factors of the current number
            $factors = $this->prime_factors($number);
        
            // Increase the number for the next iteration
            $number += 1;
        }
	}

    // Prime factorization function
    function prime_factors($n) {
        $factors = [];
        for ($divisor = 2; $n > 1; $divisor++) {
            while ($n % $divisor == 0) {
                $factors[] = $divisor;
                $n /= $divisor;
            }
        }
        return $factors;
    }
	/**
	 * Request a malware scan of the file via ajax / wp_remote_
	 *
	 * @param [type] $file
	 * @return void
	 */
	function request_file_scan( $file ) {
		$this->waste_time( 1 );
		// $this->flog( str_repeat( "\t\t\t", $this->pad ) . __FUNCTION__ . ' for ' . $file );
		// usleep( 10000 ); // 10000 = 10ms
		return;
		$data = $this->exor(
			array(
				'type' => 'file',
				'path' => $file,
			)
		);
		$this->flog( 'data ' . $data );
		$url = admin_url(
			'admin-ajax.php?action=mss_scan_file&data=' . $data
		);
		// $this->flog( __FUNCTION__ . ' url ' . $url );
		$response = wp_remote_get(
			$url
		);

		// $this->flog( 'response' );
		// $this->flog( $response );
	}

	/**
	 * Scan the file for malware
	 *
	 * @return void
	 */
	function scan_file() {

		$sec = mss_utils::get_option( 'file_indexer_state' );
		if ( empty( $sec ) || empty( $sec['identifier'] ) ) {
			$this->flog( 'Identifier is empty. Aborting.' );
			wp_die();
		}

		$sec = $sec['identifier'];

		$data = $this->dxor( $_REQUEST['data'], $sec );

		if ( ! empty( $data['type'] ) && ! empty( $data['path'] ) ) {
			// $this->flog( 'scanning: ' . $data['path'] );
		} else {
			$this->flog( 'something wrong with data: ' );
			$this->flog( 'identifier: ' . $sec );
			$this->flog( $_REQUEST );
			$this->flog( '$data' );
			$this->flog( $data );
		}
		wp_die(); // this is required to terminate immediately and return a proper response
	}

	function exor( $data ) {
		if ( empty( $this->state['identifier'] ) ) {
			$this->flog( 'exor identifier is empty' );
			return false;
		}
		$key    = $this->state['identifier'];
		$data   = json_encode( $data );
		$output = '';
		for ( $i = 0; $i < strlen( $data ); $i++ ) {
			$output .= $data[ $i ] ^ $key[ $i % strlen( $key ) ];
		}
		return urlencode( base64_encode( $output ) );
	}

	function dxor( $data, $sec ) {

		$key  = $sec;
		$data = base64_decode( urldecode( $data ) );
		if ( empty( $data ) ) {
			return false; // base64_decode returns false in case of failure
		}
		$output = '';
		for ( $i = 0; $i < strlen( $data ); $i++ ) {
			$output .= $data[ $i ] ^ $key[ $i % strlen( $key ) ];
		}
		$data = json_decode( $output, true );
		if ( empty( $data ) ) {
			return false; // json_decode returns null in case of failure
		}
		return $data;
	}

	public function quit() {
		$this->clear_state();
		wp_die();
	}

	/**
	 * Function to bulk insert the indexed files into the database
	 *
	 * @return void
	 */
	function save_files() {
		// .
		global $wpdb;

		$query = "INSERT INTO $this->scannertablename (path, checksum, type, ver) VALUES ";

		$valuePlaceholders = array();
		$params            = array();
		// $state             = $this->get_state();
		$arrFiles = array_splice( $this->state['indexed_files'], 0 );
		foreach ( $arrFiles as $key => $value ) {
			$this->flog( 'key:' . $key . ' value:' . $value );
			// $valuePlaceholders[] = '(%s, %s, %s, %s)';
			// $params[]            = $key;
			// $params[]            = $value;
			// $params[]            = @hash_file( 'sha256', $key );
			// $params[]            = $type;
			// $params[]            = $version;
		}
		// $this->state['indexed_files'] = array();

		if ( 0 && ! empty( $valuePlaceholders ) ) {
			$query .= implode( ', ', $valuePlaceholders );
			$query .= ' ON DUPLICATE KEY UPDATE checksum = VALUES(checksum), type = VALUES(type), ver = VALUES(ver)';

			$preparedQuery = $wpdb->prepare( $query, $params );
			$wpdb->query( $preparedQuery );
		}

	}

	/**
	 * Checks if a directory is valid and can be scanned
	 */
	function valid_dir( $dir ) {
		// if ( is_dir( $dir ) && ! is_link( $dir ) && ! preg_match( '/\.git\b/', $dir ) ) {
		if ( is_dir( $dir ) && ! is_link( $dir ) ) {
			return true;
		}
	}

	/**
	 * Checks if a file is valid and can be scanned
	 *
	 * @param [type] $file
	 * @return void
	 */
	function valid_file( $file ) {
		// if ( is_file( $file ) && ! is_link( $file ) && filesize( $file ) && filesize( $file ) < $this->filemaxsize ) {
		if ( is_file( $file ) && ! is_link( $file ) ) {
			return true;
		}
	}

	/**
	 * Logging function for debugging that utilizes var_dump
	 *
	 * @param [type] $obj
	 * @return void
	 */
	function get_dump( $obj ) {
		ob_start();
		var_dump( $obj );
		$result = ob_get_clean();
		return $result;
	}

	/**
	 * Logging function for debugging that utilizes print_r
	 *
	 * @param [type] $str
	 * @return void
	 */
	function flog( $str ) {
		// $s = print_r(debug_backtrace()[1],1);
		// mss_utils::flog( debug_backtrace()[1]  );
		// mss_utils::flog( debug_backtrace()[1]['function'] );
		// mss_utils::flog( debug_backtrace()[1]['line'] );
		mss_utils::flog( $str );
	}

	function get_definitions() {
		$definitions = mss_utils::get_option( 'definitions' );
		if ( ! empty( $definitions['db'] ) ) {
			return $definitions;
		}
	}

	/**
	 * Returns the version of the definitions
	 *
	 * @return void
	 */
	static function get_definition_version() {
		$definitions = mss_utils::get_option( 'definitions' );
		if ( $definitions && ! empty( $definitions['v'] ) ) {
			return $definitions['v'];
		}
	}

	/**
	 * Gets malware definitions for database only
	 *
	 * @return void
	 */
	static function get_malware_db_definitions() {
		$defs = mss_utils::get_definitions_data();
		if ( ! empty( $defs['db'] ) ) {
			return $defs['db'];
		}
	}

	/**
	 * Gets malware definitions for files only
	 */
	static function get_malware_file_definitions() {
		$defs = mss_utils::get_definitions_data();
		if ( ! empty( $defs['files'] ) ) {
			return $defs['files'];
		}
	}

}

Malcure_Malware_Scanner::get_instance();
