<?php
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Singleton Class for WordPress File Indexer
 */
final class Malcure_Malware_Scanner {
	private static $instance = null;

	// private $indexing   = false;
	private $state = false;
	private $pad   = 0;
	// private $indexed_files = array();
	// private $current_directory;

	public $filemaxsize = 1111111;

	private function __construct() {
	}

	public static function get_instance() {
		if ( self::$instance === null ) {
			self::$instance = new self();
			self::$instance->init();
		}
		return self::$instance;
	}

	function init() {
		$backtrackLimit = ini_get( 'pcre.backtrack_limit' );
		if ( is_numeric( $backtrackLimit ) ) {
			$backtrackLimit = (int) $backtrackLimit;
			if ( $backtrackLimit > 1000000 ) {
				ini_set( 'pcre.backtrack_limit', 1000000 );
				ini_set( 'pcre.recursion_limit', 1000000 );
			}
		}

		// $this->create_indexer_state_table();
		add_action( 'Malcure_security_suite_add_meta_boxes', array( $this, 'add_meta_boxes' ), 8 );
		add_action( 'wp_ajax_nopriv_mss_start_scan', array( $this, 'start_scanning' ) );
		add_action( 'wp_ajax_mss_start_scan', array( $this, 'start_scanning' ) );
	}

	function add_meta_boxes() {
		$this->flog( __FUNCTION__ );
		add_meta_box( 'mss_scanner', 'Malware Scanner', array( $this, 'scanner_meta_box' ), $GLOBALS['Malcure_security_suite']['pagehook'], 'main' );
	}

	function scanner_meta_box() {
		$this->flog( __FUNCTION__ );
		echo '<input class="mss_action" value="Click" id="mss_scan_btn" type="submit" />';
		echo '<pre>' . print_r( get_option( 'file_indexed_files' ), 1 ) . '</pre>';
		?>
		<script type="text/javascript">
			jQuery(document).ready(function($){
				$('#mss_scan_btn').click(function(){
					console.log('Initiating Scan');
					mss_start_scan = {
						mss_start_scan_nonce: '<?php echo wp_create_nonce( 'mss_start_scan' ); ?>',
						action: "mss_start_scan",
					};
					$.ajax({
						url: ajaxurl,
						method: 'POST',
						data: mss_start_scan,
						success: function(data, textStatus, jqXHR) {
							console.dir('success Data Begins');
							console.dir(data);
							console.dir(textStatus);
							console.dir(jqXHR);
							console.dir('success Data Ends');
							mss_status_updater = setTimeout(mss_update_scan_status,1000);
						},
						error: function( jqXHR, textStatus, errorThrown){},
						complete: function(jqXHR_data, textStatus) {
							console.log('This page needs to reload to watch progress.')
							// location.reload();
						},
					});
				});
			});
		</script>
		<?php
	}

	private function save_state() {
		mss_utils::update_option( 'file_indexer_state', $this->state );
		$this->flog( __FUNCTION__ );
		$file_path = trailingslashit( __DIR__ ) . 'state.txt'; // Replace with the desired file path
		file_put_contents( $file_path, serialize( $this->state ) );
	}

	private function clear_state() {
		mss_utils::delete_option( 'file_indexer_state', $this->state );
	}

	private function resume_state() {
		$state = mss_utils::get_option( 'file_indexer_state' );
		if ( $state ) {
			if ( $state && is_array( $state ) ) {
				$state = array_filter( $state );
				if ( ! empty( $state ) ) {
					$this->state = $state;
				}
			}
		}
	}

	public function start_scanning() {
		session_write_close();
		ignore_user_abort( 1 );

		$this->flog( __FUNCTION__ );
		$this->resume_state();
		if ( $this->state ) {
			$this->flog( 'Found previous state.' );
			$this->resume_indexing();
		} else {
			$this->state = array(
				// 'indexing'          => true,
				'indexed_files'      => array(),
				'stack'              => array(
					ABSPATH => array( 'counter' => 0 ),
				),
				'current_directory'  => ABSPATH,
				'previous_directory' => array(),
			);
			$this->index_files_recursively();
		}

		$this->flog( 'Final state before clearing' );
		$this->flog( $this->state );
		$this->save_files();
		$this->clear_state();
		// Save the indexed files to the database or perform any other required operations
		// $this->save_indexed_files();
	}

	function resume_indexing() {
		$this->flog( __FUNCTION__ );
		// $this->resume_state();
		$this->index_files_recursively();
	}

	public function index_files_recursively() {
		if ( strpos( $this->state['current_directory'], ABSPATH ) === false ) {
			$this->flog( 'Exiting because of strpos because current directory breaches OS: ' . $this->state['current_directory'] );
			return;
		}
		$this->flog( str_repeat( "\t\t\t", $this->pad ) );
		$this->flog( str_repeat( "\t\t\t", $this->pad ) . __FUNCTION__ . ' to scan ' . $this->state['current_directory'] );
		if ( $this->valid_dir( $this->state['current_directory'] ) ) {
			$entries = scandir( $this->state['current_directory'] );
			$entries = array_diff( $entries, array( '.', '..' ) );
			natcasesort( $entries ); // sort case insensitive "natural order" algorithm
			$entries = array_values( $entries ); // reset indices so that they start with 0
			// if ( $entries !== false ) { // if the directory is not empty
			$this->flog( str_repeat( "\t\t\t", $this->pad ) . '$entries inside ' . $this->state['current_directory'] . ' are:' );
			// $this->flog( str_repeat( "\t\t\t", $this->pad ) . implode( ',', $entries ) );
			// $this->flog( str_repeat( "\t\t\t", $this->pad ) . json_encode( $entries, JSON_FORCE_OBJECT ) );
			$this->flog( str_repeat( "\t\t\t", $this->pad ) . 'counter for current directory:' . $this->state['current_directory'] . ' is ' . $this->state['stack'][ $this->state['current_directory'] ]['counter'] );
			// $this->state['stack'][ $this->state['current_directory'] ]['counter'] );
			for ( $i = $this->state['stack'][ $this->state['current_directory'] ]['counter']; $i < count( $entries ); $i++ ) {
				$this->maybe_save_and_fork();
				$full_path = trailingslashit( $this->state['current_directory'] ) . $entries[ $this->state['stack'][ $this->state['current_directory'] ]['counter'] ];
				$this->state['stack'][ $this->state['current_directory'] ]['counter']++;

				$type = is_dir( $full_path ) ? 'dir' : 'file';
				// $this->flog( str_repeat( "\t\t\t", $this->pad ) . '$i=' . $i . ' for:' . $this->state['current_directory'] . ' points to:' . $entries[ $i ] . ' Type: ' . $type . ' Full_path:' . $full_path );
				if ( $this->valid_file( $full_path ) ) {
					$this->state['indexed_files'][] = $full_path;
					// $this->flog( str_repeat( "\t\t\t", $this->pad ) . 'INDEXED FILE:' . $full_path );
				} elseif ( $this->valid_dir( $full_path ) ) {
					$this->pad++;
					// $this->state['previous_directory'] = $this->state['current_directory']; // Set the current directory
					array_push( $this->state['previous_directory'], $this->state['current_directory'] ); // Add the directory to the stack
					$this->state['current_directory']   = $full_path; // Set the current directory
					$this->state['stack'][ $full_path ] = array( 'counter' => 0 ); // Add the directory to the stack
					// $this->flog( str_repeat( "\t\t\t", $this->pad ) . 'FOUND DIRECTORY. Starting iterating inside:' . $full_path );
					$this->index_files_recursively();
					$this->pad--;
					$prev_dir = array_pop( $this->state['previous_directory'] );
					// $this->flog( str_repeat( "\t\t\t", $this->pad ) . 'RESUMED to ' . $prev_dir . ' from ' . $this->state['current_directory'] );
					// $this->state['current_directory'] = $this->state['previous_directory']; // Set the current directory
					$this->state['current_directory'] = $prev_dir;
					// $this->state['stack'][$this->state['previous_directory']]['counter']++; // chatgpt
				}
			}
			unset( $this->state['stack'][ $this->state['current_directory'] ] );
			// } else {
				// Handle the error if scandir fails
			// $this->flog( 'No elements inside ' .$this->state['current_directory'] );
			// }
		}

	}

	public function maybe_save_and_fork() {
		$max_execution_time = ini_get( 'max_execution_time' ); // Get the max_execution_time
		$elapsed            = time() - $_SERVER['REQUEST_TIME'];
		$remaining_time     = ( $max_execution_time - $elapsed );
		$this->flog( '$elapsed:' . $elapsed . ' $remaining_time:' . $remaining_time );
		// + $max_execution_time ); // start time + max time
		if ( ! empty( $this->state['indexed_files'] ) && is_array( $this->state['indexed_files'] ) && count( $this->state['indexed_files'] ) % 100 === 0 ) {
			$this->save_files();
		}
		if ( $remaining_time <= 2 ) {
			$this->flog( __FUNCTION__ );
			// If there are 2 seconds or less remaining, save the data and exit

			$this->save_state();
			$fork = wp_remote_get(
				admin_url( 'admin-ajax.php?action=mss_start_scan' ),
				array(
					'timeout'  => 0.01,
					'blocking' => false,
				)
			);
			$this->flog( 'Exiting because of remaining_time:' . $remaining_time );
			error_log( 'Exiting because of remaining_time:' . $remaining_time );
			exit;
		} else {
			// $this->flog( 'Time has not arrived. remaining_time:' . $remaining_time . ' max_execution_time:' . $max_execution_time );
		}
	}

	function save_files() {
		.
		global $wpdb;
		$tableName = $wpdb->prefix . 'mss_files';

		$query = "INSERT INTO $tableName (path, checksum, type, ver) VALUES ";

		$valuePlaceholders = array();
		$params            = array();

		foreach ( $arrChecksums as $key => $value ) {
			$valuePlaceholders[] = '(%s, %s, %s, %s)';
			$params[]            = $key;
			$params[]            = $value;
			$params[]            = $type;
			$params[]            = $version;
		}

		if ( ! empty( $valuePlaceholders ) ) {
			$query .= implode( ', ', $valuePlaceholders );
			$query .= ' ON DUPLICATE KEY UPDATE checksum = VALUES(checksum), type = VALUES(type), ver = VALUES(ver)';

			$preparedQuery = $wpdb->prepare( $query, $params );
			$wpdb->query( $preparedQuery );
		}

	}

	function valid_dir( $dir ) {
		if ( is_dir( $dir ) && ! is_link( $dir ) && ! preg_match( '/\.git\b/', $dir ) ) {
			return true;
		}
	}

	function valid_file( $file ) {
		if ( is_file( $file ) && ! is_link( $file ) && filesize( $file ) && filesize( $file ) < $this->filemaxsize ) {
			return true;
		}
	}

	function is_cli() {
		return defined( 'WP_CLI' ) && WP_CLI;
	}

	function get_dump( $obj ) {
		ob_start();
		var_dump( $obj );
		$result = ob_get_clean();
		return $result;
	}

	function flog( $str ) {
		if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
			$date = date( 'Ymd-G:i:s' ); // 20171231-23:59:59
			$date = $date . '-' . microtime( true );

			$file = '/var/www/html/dev/plugindev/wp/wp-content/plugins/malcure-security-suite/log.log';

			$str = print_r( $str, true );
			if ( ! $this->is_cli() ) {
				file_put_contents( $file, $str . PHP_EOL, FILE_APPEND | LOCK_EX );
			} else {
				WP_CLI::log( $str );
			}
		}
	}

	function get_definitions() {
		$definitions = mss_utils::get_option( 'definitions' );
		if ( $definitions && ! empty( $definitions['db'] ) ) {
			return $definitions['db'];
		}
	}

	/**
	 * Returns the version of the definitions
	 *
	 * @return void
	 */
	static function get_definition_version() {
		$definitions = mss_utils::get_option( 'definitions' );
		if ( $definitions && ! empty( $definitions['v'] ) ) {
			return $definitions['v'];
		}
	}

	/**
	 * Gets malware definitions for database only
	 *
	 * @return void
	 */
	static function get_malware_db_definitions() {
		$defs = mss_utils::get_definitions_data();
		if ( ! empty( $defs['db'] ) ) {
			return $defs['db'];
		}
	}

	/**
	 * Gets malware definitions for files only
	 */
	static function get_malware_file_definitions() {
		$defs = mss_utils::get_definitions_data();
		if ( ! empty( $defs['files'] ) ) {
			return $defs['files'];
		}
	}

}

Malcure_Malware_Scanner::get_instance();
