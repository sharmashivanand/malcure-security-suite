<?php
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

define( 'MSS_SCANNERTABLE', 'mss_generated' );
define( 'MSS_CHECKSUMTABLE', 'mss_original' );

/**
 * Singleton Class for WordPress File Indexer
 */
final class Malcure_Malware_Scanner {

	private static $instance    = null;
	private $state              = false;
	private $tablename          = '';
	private $max_execution_time = false;
	private $os_entry_dir       = false;
	private $time_buffer        = 2;
	private $definitions        = false;

	public $filemaxsize = 1111111; // 1085.069336 KB || 1.0596380234375 MB

	private function __construct() {
	}

	public static function get_instance() {
		if ( self::$instance === null ) {
			self::$instance = new self();
			self::$instance->init();
		}
		return self::$instance;
	}

	/**
	 * Initializes hooks and filters
	 *
	 * @return void
	 */
	function init() {

		$this->max_execution_time = ini_get( 'max_execution_time' ); // Get the max_execution_time
		$backtrackLimit           = ini_get( 'pcre.backtrack_limit' );
		if ( is_numeric( $backtrackLimit ) ) {
			$backtrackLimit = (int) $backtrackLimit;
			if ( $backtrackLimit > 1000000 ) {
				ini_set( 'pcre.backtrack_limit', 1000000 );
				ini_set( 'pcre.recursion_limit', 1000000 );
			}
		}

		$this->scannertablename  = $GLOBALS['wpdb']->prefix . MSS_SCANNERTABLE;
		$this->checksumtablename = $GLOBALS['wpdb']->prefix . MSS_CHECKSUMTABLE;

		$this->os_entry_dir = ABSPATH;

		add_action( 'Malcure_security_suite_add_meta_boxes', array( $this, 'add_meta_boxes' ), 8 );

		add_action( 'wp_ajax_nopriv_mss_scan_operation', array( $this, 'scan_operation_handler' ) );
		add_action( 'wp_ajax_mss_scan_operation', array( $this, 'scan_operation_handler' ) );

		add_action( 'wp_ajax_nopriv_mss_scan_file', array( $this, 'scan_file_callback' ) );
		add_action( 'wp_ajax_mss_scan_file', array( $this, 'scan_file_callback' ) );

		add_action( 'wp_ajax_mss_scan_status', array( $this, 'scan_status_callback' ) );

		add_action( 'mss_plugin_activation', array( $this, 'db_install' ) );
		add_action( 'plugins_loaded', array( $this, 'upgrade_tables' ) );

		add_action( 'admin_footer', array( $this, 'attempt_continue' ) );

	}

	function custom_match() {
		$file          = '/_extvol_data/html/dev/plugindev/wp/h.txt';
		$file_contents = file_get_contents( $file );
		$definition    = $this->get_definitions_data();
		$definition    = $definition['files']['ZOA6CL'];
		$signature     = $this->decode( $definition['signature'] );
		print_r( $signature );
		$matches = preg_match( $signature, $file_contents, $found );

		mss_utils::llog( $matches );
		mss_utils::llog( $found );
	}

	/**
	 * Create the database tabled required for the plugin
	 *
	 * @return void
	 */
	function db_install() {
		global $wpdb;
		$charset_collate = $wpdb->get_charset_collate();

		$mss_files = "CREATE TABLE IF NOT EXISTS $this->scannertablename (
            file_id INT(11) NOT NULL AUTO_INCREMENT,
            path LONGTEXT NOT NULL UNIQUE,
            checksum LONGTEXT NOT NULL,
            sid LONGTEXT NOT NULL,
            type LONGTEXT NOT NULL,
            sver LONGTEXT NOT NULL,
            attrib LONGBLOB,
            PRIMARY KEY (file_id)
        ) $charset_collate;";

		$mss_checksums = "CREATE TABLE IF NOT EXISTS $this->checksumtablename (
            file_id INT(11) NOT NULL AUTO_INCREMENT,
            path LONGTEXT NOT NULL UNIQUE,
            checksum LONGTEXT NOT NULL,
            type LONGTEXT NOT NULL,
            ver LONGTEXT NOT NULL,
            PRIMARY KEY (file_id)
        ) $charset_collate;";

		require_once ABSPATH . 'wp-admin/includes/upgrade.php';
		dbDelta( $mss_checksums );
		dbDelta( $mss_files );
		mss_utils::update_setting( 'db_version', '1.0' );
	}

	/**
	 * Upgrade tables if required
	 *
	 * @return void
	 */
	function upgrade_tables() {
		$db_version = mss_utils::get_setting( 'db_version' );

		if ( ! $db_version || version_compare( $db_version, '1.0', '<' ) ) {
			$this->db_install();
		}
	}

	/**
	 * Adds a meta_box to admin UI for scanner
	 *
	 * @return void
	 */
	function add_meta_boxes() {
		add_meta_box( 'mss_scanner', 'Malware Scanner', array( $this, 'scanner_meta_box' ), $GLOBALS['Malcure_security_suite']['pagehook'], 'main' );
	}

	/**
	 * meta_box callback that renders the admin UI for scanner
	 *
	 * @return void
	 */
	function scanner_meta_box() {
		// $this->custom_match();
		$url = admin_url( 'admin-ajax.php?action=mss_scan_operation&operation=mss_test' );
		$url = $this->get_local_url( $url );
		$this->flog( $url );
		$test_start     = time();
		$response       = @wp_remote_get(
			$url,
			array(
				// 'timeout'   => 1,
				'blocking'  => true,
				'sslverify' => false,
				'headers'   => array(
					'mss_fork' => '1',
					'Host'     => parse_url( site_url(), PHP_URL_HOST ),
				),
			)
		);
		$test_end       = time();
		$duration_raw   = $test_end - $test_start;
		$duration_human = human_time_diff( $test_start, $test_end );

		if ( is_wp_error( $response ) ) {
			$error_message = $response->get_error_message();
			echo "Scanner failed test: $error_message";
		} else {
			$status_code = wp_remote_retrieve_response_code( $response );           // Check the HTTP response code
			if ( $status_code == 200 ) {                // The request was successful
				$body = wp_remote_retrieve_body( $response );
				$body = json_decode( $body, true );
				if ( ! is_null( $body ) ) {
					if ( ! empty( $body['success'] ) && ! empty( $body['data'] ) && ! empty( $body['data']['mss_test'] ) ) {
						echo "Scanner test. Took: $duration_human and Server responded in " . human_time_diff( $test_start, $body['data']['mss_test'] );

						$operations = array(
							'start',
							'stop',
						);

						$is_running      = (int) ! empty( $this->has_state() );
						$valid_operation = $operations[ $is_running ];
						?>
						<script type="text/javascript">
							mss_operations = <?php echo json_encode( $operations ); ?> ;
							mss_is_running = <?php echo (int) $is_running; ?>;
							mss_valid_operation = '<?php echo $valid_operation; ?>';
						</script>
						<?php
						echo '<p><input class="mss_action" style="text-transform:capitalize" value="' . $valid_operation . '" id="mss_scan_btn" type="submit" /></p>';
						?>
						<div id="mss_scan_results"><table></table></div>
						<ol>
                            <li>Implement checksum fetching on plugin / wp updates.</li>
							<li>Implement checksum obsoletion on definition updates? Why / why not? If definitions are updated, and checksums stale, will it skip file?</li>
							<li>Implement scan performance / file-rate, max_mem_ cpu etc.</li>
							<li>Implement scan progress monitoring.</li>
							<li>Implement db scan.</li>
							<li></li>
                            <li>Implement infection reporting.</li>
							<li>Troubleshoot why file can't be decrypted by scanner callback.</li>
							<li>Implement scanning suspicious files.</li>
							<li>Validate scan thoroughness like wpmr.</li>
							<li><del>Implement signature id consistency (the generated ones often have updated signature ids).</del></li>
							<li><del>Implement file scan only if doesn't match checksum.</del></li>
							<li><del>Implement file scan only if an infected file passes signature id which it failed.</del></li>
							<li><del>Implement wp_remote test before scanning.</del></li>
							<li><del>Validate scan trigger security.</del> For now, can only be triggered by logged-in user / nonce.</li>
							<li><del>Implement single scan at any given time.</del></li>
							<li><del>Implement scan cancellation.</del></li>
							<li><del>Implement attempt to restart failed scan.</del></li>
						</ol>
						<script type="text/javascript">
						var mss_results = {}; 
						jQuery(document).ready(function($){
							var mss_status_updater;
							
							if(mss_is_running){
								console.dir('Scan is already running. Setting timer.')
								set_mss_status_timer();
							}else{
								console.dir('Scan is not running.')
							}
							mss_get_status(); // at least show something right away
							mss_valid_operation = mss_operations[ mss_is_running ];
							console.log('mss_is_running on Page Load '+ mss_is_running);
							console.log('mss_valid_operation on Page Load '+ mss_valid_operation);
							$('#mss_scan_btn').click(function(){
								$('#mss_scan_btn').attr('disabled', 'disabled');
								//console.log('Initiating Scan');
								//console.log('mss_operations:' );
								//console.dir( mss_operations);
								// console.log('before mss_is_running ' +  mss_is_running);
								//console.log(mss_is_running);
								
								mss_scan_operation = {
									mss_scan_operation_nonce: '<?php echo wp_create_nonce( 'mss_scan_operation' ); ?>',
									action: "mss_scan_operation",
									operation: mss_valid_operation,
			
								};
								$.ajax({
									url: ajaxurl,
									dataType: "text",
									method: 'POST',
									data: mss_scan_operation,
									success: function(data, textStatus, jqXHR) {
										console.dir('success Data Begins');
										console.dir('data');
										console.dir(data);
										console.dir('textStatus');
										console.dir(textStatus);
										console.dir('jqXHR');
										console.dir(jqXHR);
										console.dir('jqXHR');
										// console.dir('jqXHR.responseText');
										// console.dir(jqXHR.responseText);

										$('#mss_scan_btn').removeAttr('disabled');
										// mss_is_running = Number(! mss_is_running);
										//mss_is_running = mss_operations[ ! mss_is_running ];
										//console.log('after mss_is_running '  + typeof mss_is_running);
										//console.log(mss_is_running);
										toggle_scanner_operation();
										//console.log('after mss_is_running ' +  mss_is_running);
										//console.log('valid_operation: ' + mss_valid_operation);
										if(mss_is_running){
											console.dir('Scan is running. Setting timer.')
											mss_get_status(); // show something right away
											set_mss_status_timer();
										}else{
											console.dir('Scan is cancelled. Cancelling timer.')
											clear_mss_status_timer();
										}
										// $('#mss_scan_btn').val(mss_valid_operation);
										//mss_valid_operation = mss_operations[ mss_is_running ];
										
										//console.log('TOGGLING BUTTON VALUE TO: ' + mss_valid_operation);

										
													
									},
									error: function( jqXHR, textStatus, errorThrown){
										console.dir('error Data Begins');
										console.dir('jqXHR');
										console.dir(jqXHR);
										console.dir('textStatus');
										console.dir(textStatus);
										console.dir('errorThrown');
										console.dir(errorThrown);
										// console.dir('jqXHR.responseText');
										// console.dir(jqXHR.responseText);
									},
									complete: function(jqXHR, textStatus) {
										console.log('completion Data Begins')
										console.dir('jqXHR');
										console.dir(jqXHR);
										console.dir('textStatus');
										console.dir(textStatus);
										// console.dir('jqXHR.responseText');
										// console.dir(jqXHR.responseText);
									},
								});
							});

							function set_mss_status_timer(){
								mss_status_updater = setInterval(mss_get_status,<?php echo $this->max_execution_time; ?> * 1000) ;
							}
							function clear_mss_status_timer(){
								clearInterval(mss_status_updater);
								
								// console.dir('after clearing: mss_is_running =');
								// console.dir(mss_is_running);
								// mss_is_running = Number(! mss_is_running);
								// console.dir('Toggled: mss_is_running');
								// mss_valid_operation = mss_operations[ mss_is_running ];
								// console.dir('mss_valid_operation' + mss_valid_operation);
								// $('#mss_scan_btn').val(mss_valid_operation);
							}

							function toggle_scanner_operation(){
								console.log('BEFORE : mss_is_running ' +  mss_is_running + ' mss_valid_operation ' + mss_valid_operation );
								mss_is_running = Number(! mss_is_running);
								mss_valid_operation = mss_operations[ mss_is_running ];
								console.log('AFTER  : mss_is_running ' +  mss_is_running + ' mss_valid_operation ' + mss_valid_operation );
								$('#mss_scan_btn').val(mss_valid_operation);
							}

							function mss_get_status(){
								mss_scan_status = {
									mss_scan_status_nonce: '<?php echo wp_create_nonce( 'mss_scan_status' ); ?>',
									action: "mss_scan_status",
								};
								$.ajax({
									url: ajaxurl,									
									data: mss_scan_status,
									success: function(data, textStatus, jqXHR) {
										// console.dir('scan status jqXHR');
										// console.dir(jqXHR);
										if(jqXHR.hasOwnProperty('responseJSON')){ // we got json
												console.dir(jqXHR.responseJSON);
												mss_results_response = jqXHR.responseJSON.hasOwnProperty('files') ? jqXHR.responseJSON.files : {};
												console.dir('jqXHR.responseJSON.running');
												console.dir(mss_results_response);
												
												mss_results =  mss_results_response ;
												console.dir(mss_results);
												for (let [key, value] of Object.entries(mss_results)) {
													//console.dir(value);
													$('#mss_scan_results').append('<tr class="'+value.type+'"><td>'+value.path+'</td><td><a class="sig '+value.type+'" href="<?php echo MSS_WEB_EP . '?page_id=2074&ssig='; ?>'+value.sid+'&utm_source=mss_scanrun&utm_medium=mss_web&utm_campaign=mss'+value.type+'" target="_blank">'+value.type+'</a></td></tr>');
												}
												//for (let [key, value] of Object.entries(mss_results_response)) {
												////	
												////	console.dir('key');
												//    console.dir(key);
												//    console.dir('value');
												//    console.dir(value);
												//    //mss_results.push([value.path,value.type,value.sid]);
												//    mss_results.files;
												//}
												console.dir('mss_results');
												
												//$('#mss_scan_results').html('');
												console.dir('typeof jqXHR.responseJSON.files');
												console.dir(typeof jqXHR.responseJSON.files);
												console.dir(jqXHR.responseJSON.total / (jqXHR.responseJSON.now - jqXHR.responseJSON.identifier) + ' files / sec' );
										}
									},
									error: function( jqXHR, textStatus, errorThrown){
									},
									complete: function(jqXHR, textStatus) {
										// console.dir('jqXHR');

										if(jqXHR.hasOwnProperty('responseJSON')){ // we got json
											// console.dir('ajax complete');
											// console.dir(jqXHR.responseJSON);
											// console.dir('jqXHR.responseJSON.running');
											// console.dir(jqXHR.responseJSON.running);
											if(! jqXHR.responseJSON.running) {
												console.dir('Scan is not running. Cancelling timer.')
												clear_mss_status_timer();
												toggle_scanner_operation();
												// $('#mss_scan_btn').val(mss_valid_operation);
											}
										}
									},
								})
							}
						});
					</script>
						<?php
						$status = mss_utils::get_option( 'scanner_state' );
						if ( $status ) {
							mss_utils::llog( $status['size'] );
							mss_utils::llog( $status['identifier'] );
							mss_utils::llog( $status );
						}
					} else {
						echo 'Incapable server: <pre>' . htmlentities( print_r( $body, 1 ) ) . '</pre>';
					} // empty( $body['success'] end if/else
				} else {
					echo 'Invalid JSON returned: <pre>' . htmlentities( $body ) . '</pre>';
				} // is_null end if/else
			} else {
				echo "Scanner failed test. Unexpected status code: $status_code";
			} // status_code end if/else
		}  // wp_error end if/else
	}

	function scan_status_callback() {
		$status  = mss_utils::get_option( 'scanner_state' );
		$results = $this->get_file_status();
		if ( $status ) {
			$status['identifier'] = explode( '.', $status['identifier'] )[0];
			$status['now']        = time();

			$status['files']   = $results;
			$status['running'] = true;
			wp_send_json( $status );
		}
		wp_send_json(
			array(
				'running' => false,
				'files'   => $results,
			)
		);
	}

	function get_file_status( $status = '' ) {
		global $wpdb;
		$table_name = $this->scannertablename;
		$query      = false;
		if ( empty( $status ) ) { // If status is empty, return all files which have some type
			$query = $wpdb->prepare( "SELECT * FROM $table_name WHERE type <> %s", $status );
		} else { // If status is empty, return  files which have the requisite status
			$query = $wpdb->prepare( "SELECT * FROM $table_name WHERE type = %s", $status );
		}
		$results = $wpdb->get_results( $query, ARRAY_A );
		$this->flog( $results );
		return $results;
	}

	/**
	 * Returns the state of the indexing process
	 *
	 * @return void
	 */
	function initialize_state( $jobs = array() ) {
		$state = array(
			'jobs'       => array(),
			'total'      => 0,
			// 'files'      => array(),
			'indexed'    => array(),
			'dstack'     => array(),
			'dcounter'   => array(),
			'identifier' => microtime( 1 ),
			'pad'        => 0,
			'start'      => $_SERVER['REQUEST_TIME'], // used to track max_execution_time
		);
		$state       = array_merge( $state, $jobs );
		$this->state = $state;
		$this->add_to_stack( $this->os_entry_dir );
	}

	/**
	 * Saves the state of indexing
	 *
	 * @return void
	 */
	private function save_state() {
		mss_utils::update_option( 'scanner_state', $this->state );
	}

	/**
	 * Restores the state of scanning
	 *
	 * @return void
	 */
	function restore_state() {
		$state          = mss_utils::get_option( 'scanner_state' );
		$state['start'] = $_SERVER['REQUEST_TIME'];
		$this->state    = $state;
	}

	/**
	 * Checks if the scanner has a state saved in the db. If so a scan is in progress
	 *
	 * @return boolean
	 */
	function has_state() {
		return ! empty( mss_utils::get_option( 'scanner_state' ) );
	}

	/**
	 * Clears the state of indexing
	 */
	private function clear_state() {
		mss_utils::delete_option( 'scanner_state', $this->state );
	}

	/**
	 * Main entry to scanner engine
	 *
	 * @return void
	 */
	public function scan_operation_handler() {

		if ( ! wp_doing_ajax() || empty( $_REQUEST['operation'] ) ) {
			$this->flog( '! wp_doing_ajax' );
			wp_die();
		}

		if ( $_REQUEST['operation'] == 'mss_test' ) {
			wp_send_json_success( array( 'mss_test' => time() ) );
		}

		if ( ! headers_sent() ) {
			header( 'Connection: close' );
			header( 'Content-Length: 0' );
			header( 'X-Robots-Tag: noindex' );
		}

		session_write_close();
		ignore_user_abort( 1 );

		if ( empty( $this->definitions ) ) {
			$this->definitions = $this->get_definitions();
		}

		switch ( $_REQUEST['operation'] ) {
			case 'start':
				check_ajax_referer( 'mss_scan_operation', 'mss_scan_operation_nonce' );
				if ( $this->has_state() ) {
					$this->flog( 'Scan already running. Aborting.' );
					wp_send_json_error( 'Scan already running. Aborting.' );
				}
				$this->flog( 'Start requested' );
				$this->prepare_scan_init();
				$this->flog( 'prepared init' );
				$this->traverse_filesystem();
				$this->clear_state();
				wp_send_json_success( 'Scan started.' );
				break;
			case 'continue':
				$this->flog( 'Continue requested' );
				usleep( 200000 ); // 200ms // breathe
				if ( $this->has_state() ) {
					$state = mss_utils::get_option( 'scanner_state' );
					if ( ! empty( $state['continue_token'] ) && $_REQUEST['token'] == $state['continue_token'] ) {
						$this->restore_state();
					} else {
						$this->flog( 'Continue token does not match. Got ' . $_REQUEST['token'] . ' was supposed to be ' . $state['continue_token'] . ' Aborting.' );
						wp_send_json_error( 'Continue token does not match.' );
					}
				} else {
					$this->flog( 'No state found. Aborting.' );
					wp_send_json_error( 'No state found. Aborting.' );
				}
				$this->traverse_filesystem();
				$this->flog( 'Scan completed in ' . human_time_diff( explode( '.', $this->state['identifier'] )[0], time() ) );
				$this->clear_state();
				wp_send_json_success( 'Scan completed.' );
				break;
			case 'stop':
				check_ajax_referer( 'mss_scan_operation', 'mss_scan_operation_nonce' );
				$this->flog( 'Stop requested. Scan will cancel after current iteration.' );
				wp_send_json_success( mss_utils::update_setting( 'kill_requested', true ) );
				break;
			default:
				check_ajax_referer( 'mss_scan_operation', 'mss_scan_operation_nonce' );
				wp_send_json_error( $this->flog( 'Invalid Operation.' ) );
				break;
		}

		check_ajax_referer( 'mss_scan_operation', 'mss_scan_operation_nonce' );
		wp_send_json( 'Invalid Operation' );
	}

	/**
	 * Setup && Prepare the scan for initiation
	 */
	function prepare_scan_init() {
		if ( $this->is_table_empty( $this->checksumtablename ) ) {
			$this->flog( 'Checksum table is empty. Initializing.' );
			mss_utils::update_checksums_web();
		}
		$this->flog( 'Scanner maybe_updating_definitions.' );
		$this->maybe_update_definitions();
		$this->flog( 'Scanner initializing state.' );
		$this->initialize_state();
		$this->flog( 'Scanner saving state.' );
		$this->save_state(); // save the state so that we can reference the identifier
	}

	/**
	 * Indexes files resursively
	 *
	 * @return void
	 */
	public function traverse_filesystem( $passed = array() ) {

		if ( $passed ) {
		}
		$dir     = $this->state['dstack'][ count( $this->state['dstack'] ) - 1 ];
		$entries = @scandir( $dir );
		if ( ! is_array( $entries ) ) {
			$entries = array(); // Initialize an empty array @scandir returns false on failure
		}
		$entries = array_diff( $entries, array( '.', '..' ) );
		natcasesort( $entries );
		$entries = array_values( $entries );
		for ( ;$this->state['dcounter'][ $dir ] < count( $entries ); ) {
			$this->maybe_save_and_fork(); // We are about to start a new directory, so may be save the state and attempt to fork the process
			$location = trailingslashit( $dir ) . $entries[ $this->state['dcounter'][ $dir ] ];
			$this->state['dcounter'][ $dir ]++;
			if ( $this->is_valid_file( $location ) ) {
				// $this->flog( 'Indexed File: ' . $location );
				$this->process_file( $location );
				// $this->state['files'][] = $location;
				$this->state['total']++;
				$this->state['size'] = array_key_exists( 'size', $this->state ) ? (int) $this->state['size'] + @filesize( $location ) : @filesize( $location );
				// $this->state['files'][ $location ] = true;
			}
			// $this->flog( 'Checking if ' . $location . ' is a directory. ABSPATH is ' . ABSPATH );
			if ( $this->is_valid_dir( $location ) ) {
				// $this->flog( 'Entering into :' . $location );
				$this->add_to_stack( $location );
				$this->traverse_filesystem( array( 'recursion' => 'yes' ) );
			}
		}
		$this->remove_from_stack( $dir );

		// Assume we have resumed from a previous state
		// Assume also that the state was recursing into a directory
		// We have just completed a possible recursion
		// We don't know what the previous directory is
		// so attempt to call self
		if ( count( $this->state['dstack'] ) ) { // $this->flog( '----R---- There still is something on the stack. Going Up in stack:' );
			$this->traverse_filesystem(
				array(
					'recursion'   => 'yes',
					'restoration' => 'positive',
				)
			);
		}
	}

	/**
	 * Remove directory from the stack
	 *
	 * @param [type] $dir
	 * @return void
	 */
	function add_to_stack( $location ) {
		array_push( $this->state['dstack'], $location );
		$this->state['dcounter'][ $location ] = 0;
	}

	/**
	 * Add directory to the stack
	 *
	 * @param [type] $dir
	 * @return void
	 */
	function remove_from_stack( $dir ) {
		if ( empty( $this->state['dstack'][ $dir ] ) ) {
			$this->state['dstack'] = array_filter(
				$this->state['dstack'],
				function( $value ) use ( $dir ) {
					return $value !== $dir;
				}
			);
		} else {
			$this->flog( 'Something went wrong. Investigate why. Killing self!' );
			$this->flog( $this->state );
			die();
		}
	}

	/**
	 * Checks if we are about to hit max_execution_time and forks the process if we are, using curl / wp_remote_*
	 *
	 * @return void
	 */
	public function maybe_save_and_fork() {
		if ( mss_utils::get_setting( 'kill_requested', true ) ) {
			$this->flog( 'Kill requested. Not continuing.' );
			$this->clear_state();
			mss_utils::delete_setting( 'kill_requested', true );
			wp_die();
		}
		$max_execution_time = $this->max_execution_time; // ini_get( 'max_execution_time' ); // Get the max_execution_time
		$start              = $this->state['start'];
		$now                = time();
		$elapsed            = $now - $start;
		$remaining_time     = ( $max_execution_time - $elapsed );

		if ( $remaining_time <= $this->time_buffer ) { // If there are 2 seconds or less remaining, save the data and exit
			$this->state['continue_token'] = time();
			$this->save_state();
			$url = admin_url( 'admin-ajax.php?action=mss_scan_operation&mss_fork=1&operation=continue&token=' . $this->state['continue_token'] );
			// $this->flog( 'Fork! Getting local url for: ' . $url );
			$url = $this->get_local_url( $url );
			// $this->flog( $url );
			$this->flog( str_repeat( "\t\t\t", $this->state['pad'] ) . 'Forking to ' . $url . ' because of remaining_time:' . $remaining_time . ' max_execution_time: ' . $max_execution_time . ' $start:' . $start . ' now:' . $now . ' elapsed: ' . $elapsed );
			$fork = @wp_remote_get(
				$url,
				array(
					'timeout'   => 0.01,
					'blocking'  => false,
					'sslverify' => false,
					'headers'   => array(
						'mss_fork' => '1',
						'Host'     => parse_url( site_url(), PHP_URL_HOST ),
					),
				)
			);

			// This doesn't make sense. What's going to happen to the state?
			if ( 0 && empty( $_REQUEST['mss_fork'] ) ) { // if we are not a fork already, spawn the second one also
				$this->flog( 'Spawning second thread' );
				$fork = @wp_remote_get(
					$url,
					array(
						'timeout'   => 0.01,
						'blocking'  => false,
						'sslverify' => false,
						'headers'   => array(
							'mss_fork' => '1',
							'Host'     => parse_url( site_url(), PHP_URL_HOST ),
						),
					)
				);
			}
			exit( 0 );
		} else {
		}
	}

	/**
	 * Attempt to continue the scan if it died somehow
	 *
	 * @return void
	 */
	function attempt_continue() {
		if ( $this->has_state() ) {
			$now   = $_SERVER['REQUEST_TIME'];
			$state = mss_utils::get_option( 'scanner_state' );

			if ( $state['start'] < $now - 120 ) {
				$this->flog( 'Previous scan exited at: ' . date( 'm/d/Y H:i:s', $state['start'] ) . ' attempting to restart due to ' . date( 'm/d/Y H:i:s', $now ) );
				$this->restore_state();
				$url  = admin_url( 'admin-ajax.php?action=mss_scan_operation&mss_fork=1&operation=continue&token=' . $this->state['continue_token'] );
				$url  = $this->get_local_url( $url );
				$fork = @wp_remote_get(
					$url,
					array(
						'timeout'   => 0.01,
						'blocking'  => false,
						'sslverify' => false,
						'headers'   => array(
							'mss_fork' => '1',
							'Host'     => parse_url( site_url(), PHP_URL_HOST ),
						),
					)
				);
			} else {
				$this->flog( 'It has only been ' . ( $now - $state['start'] ) . ' seconds since the last scan. Not continuing.' );
			}
		}
	}

	/**
	 * Replace the host with localhost
	 *
	 * @param [type] $url
	 * @return void
	 */
	function get_local_url( $url ) {
		$url = str_replace( parse_url( $url, PHP_URL_HOST ), 'localhost', $url );
		return $url;
	}

	/**
	 * Request a malware scan of the file via ajax / wp_remote_
	 *
	 * @param [type] $file
	 * @return void
	 */
	function process_file( $file ) {
		// $this->flog( __FUNCTION__ . ' file ' . $file );
		if ( ! $this->file_needs_scan( $file ) ) { // First run checks if the file matches or needs a thorough scan
			return;
		}
		// $this->flog( 'file needs scan: ' . $file );
		$data = $this->exor(
			array(
				'type' => 'file',
				'path' => $file,
			)
		);
		$data = $this->encode( $data );

		$this->flog( __FUNCTION__ . ' sending data to scan: ' . $data . ' with sec: ' . (string) $this->state['identifier'] );
		$url = admin_url(
			'admin-ajax.php?action=mss_scan_file&data=' . $data
		);
		$url = $this->get_local_url( $url );
		// $this->flog( __FUNCTION__ . ' needs to queue file.' . $file );
		$response = wp_remote_get(
			$url,
			array(
				'timeout'   => 0.01,
				'blocking'  => false,
				'sslverify' => false,
				'headers'   => array(
					'mss_scan' => '1',
					'Host'     => parse_url( site_url(), PHP_URL_HOST ),
				),
			)
		);
	}

	/**
	 * Check if the file qualifies for scan
	 *
	 * @param [type] $file_path
	 * @return bool
	 */
	function file_needs_scan( $file_path ) {
		global $wpdb;
		$file_path = mss_utils::realpath( $file_path );
		$checksum  = @hash_file( 'sha256', $file_path );
		if ( ! $checksum ) {
			$this->flog( 'File not accessible ' . $file_path );
			return false;
		}
		// $checksum = $checksum . 'k'; // simulate a fake checksum
		$cs_query         = $wpdb->prepare(
			"SELECT 
                file_id, 
                path, 
                checksum, 
                type, 
                ver 
            FROM {$this->checksumtablename} 
            WHERE checksum = %s",
			$checksum
		);
		$checksum_matches = $wpdb->get_results( $cs_query, ARRAY_A );
		// $this->flog( 'checksum_matches' );
		// $this->flog( $checksum_matches );
		if ( empty( $checksum_matches ) ) {
			// $this->flog( 'File needs scan ' . $file_path );
			// $this->flog( 'Checksum do not match in ' . $this->checksumtablename . ' for ' . $file_path . ' Expected ' . $checksum );
			// $this->flog( 'query' );
			// $this->flog( $cs_query );

			// die();
			$gencs_query = $wpdb->prepare(
				"SELECT 
                    path, 
                    checksum, 
                    sid, 
                    type,
                    sver,
                    attrib 
                FROM {$this->scannertablename} 
                WHERE path = %s AND checksum = %s",
				$file_path,
				$checksum
			);

			$existing_file_info = $wpdb->get_results( $gencs_query, ARRAY_A );
			if ( empty( $existing_file_info ) ) {
				$this->flog( 'No saved fileinfo or saved checksum does not match: ' . $file_path );
				return true;
			} else {
				$this->flog( "\texisting_file_info found." );
				if ( count( $existing_file_info ) > 1 ) {
					$this->flog( 'Multiple matches in existing_file_info. Investigate' );
					$this->flog( $existing_file_info );
				}
				$existing_file_info = array_pop( $existing_file_info ); // first element of the array
				if ( $existing_file_info['sver'] == $this->definitions['v'] ) { // earliest return. If the file has been scanned against the same definitions, skip
					$this->flog( "\tFile already scanned against the current definitions: " . $file_path );
					return false;
				} else {
					$this->flog( "\tFile: " . $file_path . ' was scanned against ' . $existing_file_info['sver'] . ' May need rescan with ' . $this->definitions['v'] );
				}
				$attrib = ! empty( $existing_file_info['attrib'] ) ? json_decode( $existing_file_info['attrib'], 1 ) : false;
				$mtime  = microtime( 1 );
				// IDEA IS TO RETURN FASTERT I.E AT THE FIRST CHECK
				if ( empty( $existing_file_info['type'] ) || // file doesn't have an infection status
					empty( $attrib ) || // scan-attributes are missing
					empty( $attrib['sig_hash'] ) || // sig_hash is missing
					empty( $this->definitions['definitions']['files'][ $existing_file_info['sid'] ] ) || // infection id doesn't exists in the current set of signatures
					$sig_now_hash != hash( 'sha256', $this->definitions['definitions']['files'][ $existing_file_info['sid']['signature'] ] ) // signature has changed
				) { // check if this file is infected or not
					$this->flog( "\tTook " . ( microtime( 1 ) - $mtime ) . ' to determine that file needs scan.' );
					return true;
				}

				// if so, attempt to scan against the flagged sigid
				// if sigid is missing or the file passes, then the file should be scanned
				// else not
				else {
					$this->flog( "\tTook " . ( microtime( 1 ) - $mtime ) . ' to determine that file can be skipped.' );
					$this->flog( 'File infection is the same.' );
					return false;
				}
			}
		} else { // $this->flog( 'File does not need scan ' . $file_path );
			// $this->flog( 'WP file matches core checksums: ' . $file_path );
			return false;
		}
	}

	/**
	 * Decode and queue the file for scanning
	 *
	 * @return void
	 */
	function scan_file_callback() {
		if ( ! wp_doing_ajax() ) {
			$this->flog( '! wp_doing_ajax' );
			wp_die();
		}
		if ( ! headers_sent() ) {
			header( 'Connection: close' );
			header( 'Content-Length: 0' );
			header( 'X-Robots-Tag: noindex' );
		}
		session_write_close();
		ignore_user_abort( 1 );
		$sec = mss_utils::get_option( 'scanner_state' );
		if ( empty( $sec ) || empty( $sec['identifier'] ) ) {
			$this->flog( 'Identifier is empty. Aborting.' );
			wp_die();
		}

		$sec  = (string) $sec['identifier'];
		$data = $this->decode( $_REQUEST['data'] );
		$data = $this->dxor( $data, $sec );

		if ( ! empty( $data['type'] ) && ! empty( $data['path'] ) ) {
			$this->scan_file_threats( $data['path'] );
			$this->flog( "\tsuccessfully scanned: " . $data['path'] );
		} else {
			$this->flog( 'something wrong with data: ' );
			$this->flog( 'identifier: ' . $sec );
			$this->flog( "\t" . print_r( $_REQUEST, 1 ) );
			$this->flog( '' );
			// $this->flog( '$data' );
			// $this->flog( $data );
		}
		wp_die(); // this is required to terminate immediately and return a proper response
	}

	function debug( $file = '' ) {
		if ( preg_match( '/1\.txt/', $file ) ) {
			return true;
		}
	}
	/**
	 * Scan the file for malware
	 *
	 * @param [type] $file
	 * @return void
	 */
	function scan_file_threats( $file ) {

		$this->is_valid_file( $file );
		$file_contents = @file_get_contents( $file );
		$ext           = $this->get_fileext( $file );
		$tests         = array();

		$definitions = $this->get_malware_file_definitions();

		$sver = $this->get_definition_version();
		if ( strpos( @ini_get( 'disable_functions' ), 'ini_set' ) === false ) {
			@ini_set( 'pcre.backtrack_limit', 1000000 );
		}

		foreach ( $definitions as $definition => $signature ) {
			if ( $signature['severity'] == 'suspicious' ) {
				// $this->flog( 'Skipping suspicious signature.' );
				continue;
			}
			if ( $signature['class'] == 'htaccess' && $ext != 'htaccess' ) {
				// $this->flog( 'Skipping non-htaccess file.' );
				continue;
			}

			try {
				// if ( $this->debug( $file ) ) {
				// $this->flog( 'Def: ' . $definition );
				// $this->flog( 'Sig: ' . $this->decode( $signature['signature'] ) );
				// $this->flog( 'File: ' . $file );
				// $this->flog( 'File contents: ' . $file_contents );
				//
				// }
				$matches = preg_match( $this->decode( $signature['signature'] ), $file_contents, $found );
				// if ( $this->debug( $file ) ) {
				// $this->flog( 'Matches: ' . $matches );
				// $this->flog( 'Found: ' . print_r( $found, 1 ) );
				//
				// }
			} catch ( Exception $e ) {
				$this->flog( 'Faulty Signature: ' . $definition );
				$this->flog( 'Faulty Pattern: ' . $this->decode( $signature['signature'] ) );
				$this->flog( 'File: ' . $file );
				$this->flog( $e->getMessage() );
				continue;
			}
			if ( $matches >= 1 ) {
				$this->flog( 'Definite match found in ' . $file );
				$this->flog( $matches );
				if ( in_array( $signature['severity'], array( 'severe', 'high' ) ) ) {
					mss_utils::update_setting( 'infected', true );
				}
				// if ( $this->debug( $file ) ) {
				// die();
				// }
				return $this->save_file_status( $file, $definition, $signature, $sver ); // file, sigid, severity, dver
			}
		}
		// if ( $this->debug( $file ) ) {
		// $this->flog( 'No match found in ' . $file );
		// die();
		// }
		return $this->save_file_status( $file, '', '', $sver );
	}

	/**
	 * Save file status into the database
	 *
	 * @param [type] $file: path to file
	 * @param [type] $definition_id: sigid
	 * @param [type] $status: severity
	 * @param [type] $sver: dver
	 * @return void
	 */
	function save_file_status( $file, $sid, $signature, $sver, $attrib = array() ) {
		global $wpdb;

		// Table name
		$table_name = $this->scannertablename;

		$checksum = @hash_file( 'sha256', $file );
		if ( ! $checksum ) {
			$checksum = '';
		}
		// file_id
		// path
		// checksum
		// status
		// type
		// sver
		// attrib
		$severity = false;
		if ( ! empty( $signature ) ) {
			$attrib['sig_hash'] = hash( 'sha256', $signature['signature'] );
			$severity           = $signature['severity'];
		}

		$query = $wpdb->prepare( // Prepare the query
			"INSERT INTO $table_name ( path, checksum, sid, type, sver, attrib) VALUES (%s, %s, %s, %s, %s, %s) 
            ON DUPLICATE KEY UPDATE checksum = VALUES(checksum), sid = VALUES(sid), type = VALUES(type), sver = VALUES(sver), attrib = VALUES(attrib)",
			$file,
			$checksum,
			$sid,
			$severity,
			$sver,
			json_encode( $attrib )
		);
		sleep( rand( 1, $this->max_execution_time - 1 ) ); // bring down the load randomly
		$result = $wpdb->query( $query );       // Execute the query
		return $result;
	}

	/**
	 * Checks if newer definition version is available. If so, update defintiions.
	 *
	 * @return void
	 */
	function maybe_update_definitions() {
		if ( mss_utils::definition_updates_available() ) {
			$this->flog( 'definition updates available' );
			return mss_utils::update_definitions();
		} else {
			$this->flog( 'no definition updates available' );
		}
	}

	/**
	 * Gets malware definitions for database only
	 *
	 * @return void
	 */
	function get_malware_db_definitions() {
		$defs = mss_utils::get_option_definitions();
		if ( ! empty( $defs['definitions']['db'] ) ) {
			return $defs['definitions']['db'];
		} else {
			return array();
		}
	}

	/**
	 * Gets malware definitions for files only
	 */
	function get_malware_file_definitions() {
		$defs = $this->get_definitions();
		if ( ! empty( $defs['definitions']['files'] ) ) {
			return $defs['definitions']['files'];
		} else {
			$this->flog( 'no defs' );
			return array();
		}
	}

	/**
	 * Returns the version of the definitions
	 *
	 * @return void
	 */
	function get_definition_version() {
		$definitions = $this->get_definitions();
		if ( $definitions && ! empty( $definitions['v'] ) ) {
			return $definitions['v'];
		}
	}

	/**
	 * Gets the definitions from the database
	 */
	function get_definitions_data() {
		$definitions = $this->get_definitions();
		if ( ! empty( $definitions['definitions'] ) ) {
			return $definitions['definitions'];
		} else {
			$this->flog( 'no defs' );
			return array();
		}
	}
	/**
	 * Gets the definitions from the database
	 */
	function get_definitions() {
		$definitions = mss_utils::get_option_definitions();
		if ( ! empty( $definitions ) ) {
			return $definitions;
		} else {
			$this->flog( 'no definitions' );
			return array();
		}
	}

	// UTILITY FUNCTIONS

	/**
	 * Returns the file extension
	 */
	function get_fileext( $filename ) {
		$nameparts = explode( '.', ".$filename" );
		return strtolower( $nameparts[ ( count( $nameparts ) - 1 ) ] );
	}

	/**
	 * Checks if the table is empty. Used to test if initial checksums need to be fetched
	 *
	 * @param [type] $table_name
	 * @return boolean
	 */
	function is_table_empty( $table_name ) {
		global $wpdb;
		$table_name = sanitize_text_field( $table_name ); // Sanitize the table name to ensure it's a valid SQL identifier
		$count      = $wpdb->get_var( "SELECT COUNT(*) FROM $table_name" ); // Query to count the number of rows in the table
		return $count == 0; // Check if the count is zero
	}

	function waste_time( $seconds ) {
		$start_time = time();

		$this->number = 1.61803398874989484820458683436563811772030917980576286213544862270526046281890;
		// $this->flog( 'Need to waste ' . $seconds . ' seconds' );
		while ( true ) {
			$elapsed_time   = time() - $start_time;
			$remaining_time = $this->max_execution_time - $elapsed_time;
			$remaining_time = $this->max_execution_time - $elapsed_time;
			if ( $remaining_time <= $seconds || $remaining_time <= $this->time_buffer ) {
				break;
			}
			$this->number = $this->number * ( 1 + sqrt( 5 ) ) / 2; // Get the prime factors of the current number
		}
	}

	function exor( $data ) {
		if ( empty( $this->state['identifier'] ) ) {
			$this->flog( 'encryption identifier is empty' );
			return false;
		}
		$key    = (string) $this->state['identifier'];
		$data   = json_encode( $data );
		$output = '';
		for ( $i = 0; $i <
		strlen( $data ); $i++ ) {
			$output .= $data[ $i ] ^
			$key[ $i %
			strlen( $key ) ];
		}
		return urlencode( base64_encode( $output ) );
	}

	function dxor( $data, $key ) {
		$key  = (string) $key;
		$data = base64_decode( urldecode( $data ) );
		if ( empty( $data ) ) {
			return false; // base64_decode returns false in case of failure
		}
		$output = '';
		for ( $i = 0; $i < strlen( $data ); $i++ ) {
			$output .= $data[ $i ] ^
			 $key[ $i %
			  strlen( $key ) ];
		}
		$data = json_decode( $output, true );
		if ( empty( $data ) ) {
			return false; // json_decode returns null in case of failure
		}
		return $data;
	}

	/**
	 * Checks if a directory is valid and can be scanned
	 */
	function is_valid_dir( $dir ) {
		if ( is_dir( $dir ) && ! is_link( $dir ) && is_readable( $dir ) &&
			$dir !== untrailingslashit( ABSPATH ) && ! file_exists( trailingslashit( $dir ) . '.mcignore' )
			) {
			return true;
		}
	}

	/**
	 * Checks if a file is valid and can be scanned
	 *
	 * @param [type] $file
	 * @return void
	 */
	function is_valid_file( $file ) {
		if ( is_file( $file ) && ! is_link( $file ) && is_readable( $file ) && filesize( $file ) && filesize( $file ) < $this->filemaxsize ) {
			return true;
		}
	}

	/**
	 * Logging function for debugging that utilizes var_dump
	 *
	 * @param [type] $obj
	 * @return void
	 */
	function get_dump( $obj ) {
		ob_start();
		var_dump( $obj );
		$result = ob_get_clean();
		return $result;
	}

	function encode( $str ) {
		return strtr( base64_encode( json_encode( $str ) ), '+/=', '-_,' );
	}

	function decode( $str ) {
		return json_decode( base64_decode( strtr( $str, '-_,', '+/=' ) ), true );
	}

	/**
	 * Logging function for debugging that utilizes print_r
	 *
	 * @param [type] $str
	 * @return void
	 */
	function flog( $str ) {
		// $s = print_r(debug_backtrace()[1],1);
		// mss_utils::flog( debug_backtrace()[1]  );
		// mss_utils::flog( debug_backtrace()[1]['function'] );
		// mss_utils::flog( debug_backtrace()[1]['line'] );
		mss_utils::flog( $str );
		return true;
	}

}

Malcure_Malware_Scanner::get_instance();
