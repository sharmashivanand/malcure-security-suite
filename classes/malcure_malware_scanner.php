<?php
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Singleton Class for WordPress File Indexer
 */
final class Malcure_Malware_Scanner {
	private static $instance = null;
	private $state           = false;
	// private $pad                = 0;
	private $tablename          = '';
	private $max_execution_time = false;
	private $os_entry_dir       = false;
	private $time_buffer        = 2;


	public $filemaxsize = 1111111;

	private function __construct() {
	}

	public static function get_instance() {
		if ( self::$instance === null ) {
			self::$instance = new self();
			self::$instance->init();
		}
		return self::$instance;
	}

	/**
	 * Initializes hooks and filters
	 *
	 * @return void
	 */
	function init() {
		// ini_set( 'max_execution_time', 5 );
		// ini_set( 'max_execution_time', 5 );
		// ini_set( 'error_log', '/var/www/html/dev/plugindev/wp/wp-content/plugins/malcure-security-suite/log.log' );

		$this->max_execution_time = ini_get( 'max_execution_time' ); // Get the max_execution_time
		$backtrackLimit           = ini_get( 'pcre.backtrack_limit' );
		if ( is_numeric( $backtrackLimit ) ) {

			$backtrackLimit = (int) $backtrackLimit;
			if ( $backtrackLimit > 1000000 ) {
				ini_set( 'pcre.backtrack_limit', 1000000 );
				ini_set( 'pcre.recursion_limit', 1000000 );
			}
		}

		$this->scannertablename  = $GLOBALS['wpdb']->prefix . 'mss_files';
		$this->checksumtablename = $GLOBALS['wpdb']->prefix . 'mss_checksums';

		$this->os_entry_dir = ABSPATH;

		add_action( 'Malcure_security_suite_add_meta_boxes', array( $this, 'add_meta_boxes' ), 8 );

		add_action( 'wp_ajax_nopriv_mss_start_scan', array( $this, 'init_continue_scan' ) );
		add_action( 'wp_ajax_mss_start_scan', array( $this, 'init_continue_scan' ) );

		add_action( 'wp_ajax_nopriv_mss_scan_file', array( $this, 'scan_file' ) );
		add_action( 'wp_ajax_mss_scan_file', array( $this, 'scan_file' ) );

		add_action( 'mss_plugin_activation', array( $this, 'db_install' ) );
		add_action( 'plugins_loaded', array( $this, 'upgrade_tables' ) );
	}

	/**
	 * Create the database tabled required for the plugin
	 *
	 * @return void
	 */
	function db_install() {
		global $wpdb;
		$table_mss_checksums = $wpdb->prefix . 'mss_checksums';
		$charset_collate     = $wpdb->get_charset_collate();

		$mss_files     = "CREATE TABLE IF NOT EXISTS $this->scannertablename (
            file_id INT(11) NOT NULL AUTO_INCREMENT,
            path LONGTEXT NOT NULL UNIQUE,
            checksum LONGTEXT NOT NULL,
            status LONGTEXT NOT NULL,
            type LONGTEXT NOT NULL,
            sver LONGTEXT NOT NULL,
            attrib LONGBLOB,
            PRIMARY KEY (file_id)
        ) $charset_collate;";
		$mss_checksums = "CREATE TABLE IF NOT EXISTS $this->checksumtablename (
            file_id INT(11) NOT NULL AUTO_INCREMENT,
            path LONGTEXT NOT NULL UNIQUE,
            checksum LONGTEXT NOT NULL,
            type LONGTEXT NOT NULL,
            ver LONGTEXT NOT NULL,
            PRIMARY KEY (file_id)
        ) $charset_collate;";

		require_once ABSPATH . 'wp-admin/includes/upgrade.php';
		dbDelta( $mss_checksums );
		dbDelta( $mss_files );
		mss_utils::update_setting( 'db_version', '1.0' );
	}

	/**
	 * Upgrade tables if required
	 *
	 * @return void
	 */
	function upgrade_tables() {
		// $this->db_install();
		$db_version = mss_utils::get_setting( 'db_version' );

		if ( ! $db_version || version_compare( $db_version, '1.0', '<' ) ) {
			$this->db_install();
		}
	}

	/**
	 * Adds a meta_box to admin UI for scanner
	 *
	 * @return void
	 */
	function add_meta_boxes() {
		// $this->flog( __FUNCTION__ );
		add_meta_box( 'mss_scanner', 'Malware Scanner', array( $this, 'scanner_meta_box' ), $GLOBALS['Malcure_security_suite']['pagehook'], 'main' );
	}

	/**
	 * meta_box callback that renders the admin UI for scanner
	 *
	 * @return void
	 */
	function scanner_meta_box() {
		$this->maybe_update_definitions();
		// $this->flog( __FUNCTION__ );
		echo '<input class="mss_action" value="Click" id="mss_scan_btn" type="submit" />';
		echo '<pre>' . print_r( get_option( 'file_indexed_files' ), 1 ) . '</pre>';

		?>
		<script type="text/javascript">
			jQuery(document).ready(function($){
				$('#mss_scan_btn').click(function(){
					console.log('Initiating Scan');
					mss_start_scan = {
						mss_start_scan_nonce: '<?php echo wp_create_nonce( 'mss_start_scan' ); ?>',
						action: "mss_start_scan",
					};
					$.ajax({
						url: ajaxurl,
						method: 'POST',
						data: mss_start_scan,
						success: function(data, textStatus, jqXHR) {
							console.dir('success Data Begins');
							console.dir(data);
							console.dir(textStatus);
							console.dir(jqXHR);
							console.dir('success Data Ends');
							mss_status_updater = setTimeout(mss_update_scan_status,1000);
						},
						error: function( jqXHR, textStatus, errorThrown){},
						complete: function(jqXHR_data, textStatus) {
							console.log('This page needs to reload to watch progress.')
						},
					});
				});
			});
		</script>
		<?php
	}


	function has_state() {
		return ! empty( mss_utils::get_option( 'file_indexer_state' ) );
	}

	function restore_state() {
		$this->state = mss_utils::get_option( 'file_indexer_state' );
	}

	/**
	 * Saves the state of indexing
	 *
	 * @return void
	 */
	private function save_state() {
		mss_utils::update_option( 'file_indexer_state', $this->state );
	}

	/**
	 * Clears the state of indexing
	 */
	private function clear_state() {
		mss_utils::delete_option( 'file_indexer_state', $this->state );
	}

	/**
	 * Returns the state of the indexing process
	 *
	 * @return void
	 */
	function initialize_state( $jobs = array() ) {
		$state = array(
            'jobs' => array(),
			'total'      => 0,
			'files'      => array(),
			'indexed'    => array(),
			'dstack'     => array(),
			'dcounter'   => array(),
			'identifier' => microtime( 1 ),
			'pad'        => 0,
		);
        $state = array_merge( $state, $jobs );
        $this->state = $state;
		$this->add_to_stack( $this->os_entry_dir );
	}

    function prepare_scan_init(){
        $this->maybe_update_definitions();
        // if this has state then continue that state?
        // else trigger new scan
    }

	public function init_continue_scan() {
		if ( ! empty( $_REQUEST['mss_fork'] ) ) {
			$this->flog( '' );
			$this->flog( '' );
			// $this->flog( '================' );
			// $this->flog( '====Fork initiated' );
			// $this->flog( '================' );
		}
		if ( ! wp_doing_ajax() ) {
			$this->flog( '! wp_doing_ajax' );
			wp_die();
		}
		// return;
		session_write_close();
		ignore_user_abort( 1 );

		// $this->flog( __FUNCTION__ );

		$this->start = $_SERVER['REQUEST_TIME'];

		if ( $this->has_state() ) {
			$this->restore_state();
		} else {
            $this->maybe_update_definitions();
			$this->flog( 'Resetting Log.' );
			mss_utils::clear_log();
			$this->flog( 'Creating state.' );
			$this->initialize_state();
			// $this->flog( $this->state );
			$this->save_state(); // save the state so that we can reference the identifier
		}
		$this->index_files_recursively();
		$this->flog( 'Final state before clearing' );
		// unset( $this->state['logged'] );
		$this->flog( $this->state );
		$this->clear_state();
		wp_die();
	}

	/**
	 * Indexes files resursively
	 *
	 * @return void
	 */
	public function index_files_recursively( $passed = array() ) {

		// if ( empty( $this->state['dstack'] ) ) {
		// $this->flog( 'Nothing to index' );
		// return;
		// }
		if ( $passed ) {
			// $this->flog( '$passed' );
			// $this->flog( $passed );
			// $this->flog( 'EXPLICIT STATE LOG CALLED' );
			// $this->log_state( $this->state );
			// $this->flog( 'EXPLICIT STATE LOG ENDS' );
			// exit();
		}
		$dir = $this->state['dstack'][ count( $this->state['dstack'] ) - 1 ];
		// $this->flog( 'dir to index is ' . $dir . ' and its dcounter is ' . $this->state['dcounter'][ $dir ] );
		// $this->state['dcounter'][ $dir ] = isset( $this->state['dcounter'][ $dir ] ) ? $this->state['dcounter'][ $dir ] : 0;
		$entries = @scandir( $dir );
		if ( ! is_array( $entries ) ) {
			$entries = array(); // Initialize an empty array @scandir returns false on failure
		}
		$entries = array_diff( $entries, array( '.', '..' ) );
		natcasesort( $entries );
		$entries = array_values( $entries );
		// $this->state['list'][ $dir ] = $entries;
		// $this->flog( 'Entries of ' . $dir . ' are ' . var_export( $entries, 1 ) );
		// while ( count( $this->state['dstack'] ) ) {
		for ( ;$this->state['dcounter'][ $dir ] < count( $entries ); ) {
			$this->maybe_save_and_fork(); // We are about to start a new directory, so may be save the state and attempt to fork the process
			$location = trailingslashit( $dir ) . $entries[ $this->state['dcounter'][ $dir ] ];
			$this->state['dcounter'][ $dir ]++;

			if ( $this->is_valid_file( $location ) ) {
				// $this->flog( 'Indexed File  :' . $location );
				$this->request_file_scan( $location );
				$this->state['files'][] = $location;
				$this->state['total']++;

				// $this->state['files'][ $location ] = true;
			}
			if ( $this->is_valid_dir( $location ) ) {
				$this->flog( 'Entering into :' . $location );
				$this->add_to_stack( $location );
				$this->index_files_recursively( array( 'recursion' => 'yes' ) );
			}
		}
		// $this->flog( 'Indexing of directory ' . $dir . ' completed. Here is the state before removing from stack.' );
		// $this->log_state( $this->state );
		$this->remove_from_stack( $dir );
		// }

		// Assume we have resumed from a previous state
		// Assume also that the state was recursing into a directory
		// We have just completed a possible recursion
		// We don't know what the previous directory is
		// so attempt to call self
		if ( count( $this->state['dstack'] ) ) {
			// $this->flog( '----R---- There still is something on the stack. Going Up in stack:' );
			// $this->flog( $this->state['dstack'] );
			$this->index_files_recursively(
				array(
					'recursion'   => 'yes',
					'restoration' => 'positive',
				)
			);
		}
	}

	/**
	 * Checks if we are about to hit max_execution_time and forks the process if we are, using curl / wp_remote_*
	 *
	 * @return void
	 */
	public function maybe_save_and_fork() {
		// $this->quit();
		$max_execution_time = $this->max_execution_time; // ini_get( 'max_execution_time' ); // Get the max_execution_time
		$start              = $this->start;
		$now                = time();
		$elapsed            = $now - $start;
		$remaining_time     = ( $max_execution_time - $elapsed );
		// $this->flog( '$elapsed:' . $elapsed . ' $remaining_time:' . $remaining_time );

		if ( $remaining_time <= $this->time_buffer ) { // If there are 2 seconds or less remaining, save the data and exit
			// $this->flog( __FUNCTION__ );
			// $this->flog('Saving state before forking');
			// $this->flog($this->state);
			$this->save_state();
			$url = admin_url( 'admin-ajax.php?action=mss_start_scan&mss_fork=1' );
			$this->flog( str_repeat( "\t\t\t", $this->state['pad'] ) . 'Forking to ' . $url . ' because of remaining_time:' . $remaining_time . ' max_execution_time: ' . $max_execution_time . ' $start:' . $start . ' now:' . $now . ' elapsed: ' . $elapsed );
			$fork = @wp_remote_get(
				$url,
				array(
					'timeout'   => 0.01,
					'blocking'  => false,
					'sslverify' => false,
					'headers'   => array(
						'mss_fork' => '1',
					),
				)
			);
			// $this->flog( $fork );
			// error_log( 'Exiting because of remaining_time:' . $remaining_time );
			exit( 0 );
			// wp_die();
		} else {
		}
	}

	function add_to_stack( $location ) {
		array_push( $this->state['dstack'], $location );
		$this->state['dcounter'][ $location ] = 0;
		// $this->flog( 'Added ' . $location . ' to stack' );
	}

	function remove_from_stack( $dir ) {
		// $this->flog( 'Removing ' . $dir . ' from stack by ' . __FUNCTION__ . ' Here\'s the directory in the stack' );
		if ( empty( $this->state['dstack'][ $dir ] ) ) {
			// $this->flog( 'Empty received. Attempting removal' );
			$this->state['dstack'] = array_filter(
				$this->state['dstack'],
				function( $value ) use ( $dir ) {
					return $value !== $dir;
				}
			);
			// $this->flog( 'After removal' );
			// $this->log_state( $this->state );
		} else {
			$this->flog( 'Something went wrong> Killing self' );
			die();
		}
		// $this->flog( $this->state['dstack'][ $dir ] );
		// unset( $this->state['dstack'][ $dir ] );
		// $this->flog( 'State after Removing ' );
		// $this->log_state( $this->state );
		// $removed = array_pop( $this->state['dstack'] );
		// $this->flog( 'Removed ' . $removed . ' from stack' );
		// return $removed;
		// $this->state['dcounter'][ $location ] = 0;
	}

	function waste_time( $seconds ) {
		$start_time = time();

		$this->number = 1.61803398874989484820458683436563811772030917980576286213544862270526046281890;
		// $this->flog( 'Need to waste ' . $seconds . ' seconds' );
		while ( true ) {
			$elapsed_time   = time() - $start_time;
			$remaining_time = $this->max_execution_time - $elapsed_time;
			$remaining_time = $this->max_execution_time - $elapsed_time;
			// $this->flog( 'elapsed_time: ' . $elapsed_time . ' remaining_time: ' . $remaining_time );
			if ( $remaining_time <= $seconds || $remaining_time <= $this->time_buffer ) {
				// $this->flog( 'BREAKING elapsed_time: ' . $elapsed_time . ' remaining_time: ' . $remaining_time . ' time_buffer: ' . $this->time_buffer );
				break;
			}
			// Get the prime factors of the current number
			$this->number = $this->number * ( 1 + sqrt( 5 ) ) / 2;
		}
	}

	/**
	 * Request a malware scan of the file via ajax / wp_remote_
	 *
	 * @param [type] $file
	 * @return void
	 */
	function request_file_scan( $file ) {
		// $this->waste_time( 1 );
		$this->flog( __FUNCTION__ . ' for ' . $file );
		// usleep( 10000 ); // 10000 = 10ms
		// return;
		$data = $this->exor(
			array(
				'type' => 'file',
				'path' => $file,
			)
		);
		// $this->flog( 'data ' . $data );
		$url = admin_url(
			'admin-ajax.php?action=mss_scan_file&data=' . $data
		);
		// $this->flog( __FUNCTION__ . ' url ' . $url );
		$response = wp_remote_get(
			$url,
            array(
                'timeout'   => 0.01,
                'blocking'  => false,
                'sslverify' => false,
                'headers'   => array(
                    'mss_scan' => '1',
                ),
            )
		);

		// $this->flog( 'response' );
		// $this->flog( $response );
	}

	/**
	 * Scan the file for malware
	 *
	 * @return void
	 */
	function scan_file() {

		$sec = mss_utils::get_option( 'file_indexer_state' );
		if ( empty( $sec ) || empty( $sec['identifier'] ) ) {
			$this->flog( 'Identifier is empty. Aborting.' );
			wp_die();
		}

		$sec = (string) $sec['identifier'];

		$data = $this->dxor( $_REQUEST['data'], $sec );

		if ( ! empty( $data['type'] ) && ! empty( $data['path'] ) ) {
			$this->flog( 'scanning: ' . $data['path'] );
		} else {
			$this->flog( 'something wrong with data: ' );
			$this->flog( 'identifier: ' . $sec );
			$this->flog( $_REQUEST );
			$this->flog( '$data' );
			$this->flog( $data );
		}
		wp_die(); // this is required to terminate immediately and return a proper response
	}

	function exor( $data ) {
		if ( empty( $this->state['identifier'] ) ) {
			$this->flog( 'exor identifier is empty' );
			return false;
		}
		$key    = (string) $this->state['identifier'];
		$data   = json_encode( $data );
		$output = '';
        // $this->flog('Key:' . $key . ' strlen:' . strlen( $key ));
		for ( $i = 0; $i < 
        strlen( $data ); $i++ ) {
			$output .= $data[ $i ] ^ 
            $key[ $i % 
            strlen( $key ) ];
		}
		return urlencode( base64_encode( $output ) );
	}

	function dxor( $data, $key ) {
        $key = (string) $key;
		$data = base64_decode( urldecode( $data ) );
		if ( empty( $data ) ) {
			return false; // base64_decode returns false in case of failure
		}
		$output = '';
		for ( $i = 0; $i < strlen( $data ); $i++ ) {
			$output .= $data[ $i ] ^
             $key[ $i %
              strlen( $key ) ];
		}
		$data = json_decode( $output, true );
		if ( empty( $data ) ) {
			return false; // json_decode returns null in case of failure
		}
		return $data;
	}

	public function quit() {
		$this->clear_state();
		wp_die();
	}

	/**
	 * Checks if a directory is valid and can be scanned
	 */
	function is_valid_dir( $dir ) {
		// if ( is_dir( $dir ) && ! is_link( $dir ) && ! preg_match( '/\.git\b/', $dir ) ) {
		if ( is_dir( $dir ) && ! is_link( $dir ) ) {
			return true;
		}
	}

	/**
	 * Checks if a file is valid and can be scanned
	 *
	 * @param [type] $file
	 * @return void
	 */
	function is_valid_file( $file ) {
		// if ( is_file( $file ) && ! is_link( $file ) && filesize( $file ) && filesize( $file ) < $this->filemaxsize ) {
		if ( is_file( $file ) && ! is_link( $file ) ) {
			return true;
		}
	}

	/**
	 * Logging function for debugging that utilizes var_dump
	 *
	 * @param [type] $obj
	 * @return void
	 */
	function get_dump( $obj ) {
		ob_start();
		var_dump( $obj );
		$result = ob_get_clean();
		return $result;
	}

	/**
	 * Logging function for debugging that utilizes print_r
	 *
	 * @param [type] $str
	 * @return void
	 */
	function flog( $str ) {
		// $s = print_r(debug_backtrace()[1],1);
		// mss_utils::flog( debug_backtrace()[1]  );
		// mss_utils::flog( debug_backtrace()[1]['function'] );
		// mss_utils::flog( debug_backtrace()[1]['line'] );
		mss_utils::flog( $str );
		return true;
	}

	function maybe_update_definitions() {
		if ( mss_utils::definition_updates_available() ) {
			return mss_utils::update_definitions();
		}
	}

	function get_definitions() {
		$definitions = mss_utils::get_option_definitions();
		if ( ! empty( $definitions ) ) {
			return $definitions;
		}
	}

	/**
	 * Returns the version of the definitions
	 *
	 * @return void
	 */
	static function get_definition_version() {
		$definitions = mss_utils::get_option_definitions();
		if ( $definitions && ! empty( $definitions['v'] ) ) {
			return $definitions['v'];
		}
	}

	/**
	 * Gets malware definitions for database only
	 *
	 * @return void
	 */
	static function get_malware_db_definitions() {
		$defs = mss_utils::get_option_definitions();
		if ( ! empty( $defs['db'] ) ) {
			return $defs['db'];
		}
	}

	/**
	 * Gets malware definitions for files only
	 */
	static function get_malware_file_definitions() {
		$defs = mss_utils::get_definitions_data();
		if ( ! empty( $defs['files'] ) ) {
			return $defs['files'];
		}
	}

}

Malcure_Malware_Scanner::get_instance();
