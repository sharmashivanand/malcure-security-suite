<?php
if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Singleton Class for WordPress File Indexer
 */
final class Malcure_Malware_Scanner {
	private static $instance = null;

	// private $indexing   = false;
	private $state = false;
	private $pad   = 0;
	// private $indexed_files = array();
	// private $current_directory;

	public $filemaxsize = 1111111;

	private function __construct() {
	}

	public static function get_instance() {
		if ( self::$instance === null ) {
			self::$instance = new self();
			self::$instance->init();
		}
		return self::$instance;
	}

	function init() {
		ini_set( 'max_execution_time', 5 );

		// $this->create_indexer_state_table();
		add_action( 'Malcure_security_suite_add_meta_boxes', array( $this, 'add_meta_boxes' ), 8 );
		add_action( 'wp_ajax_nopriv_mss_start_scan', array( $this, 'start_scanning' ) );
		add_action( 'wp_ajax_mss_start_scan', array( $this, 'start_scanning' ) );
	}

	function add_meta_boxes() {
		$this->flog( __FUNCTION__ );
		add_meta_box( 'mss_scanner', 'Malware Scanner', array( $this, 'scanner_meta_box' ), $GLOBALS['Malcure_security_suite']['pagehook'], 'main' );
	}

	function scanner_meta_box() {
		$this->flog( __FUNCTION__ );
		echo '<input class="mss_action" value="Click" id="mss_scan_btn" type="submit" />';
		echo '<pre>' . print_r( get_option( 'file_indexed_files' ), 1 ) . '</pre>';
		?>
		<script type="text/javascript">
			jQuery(document).ready(function($){
				$('#mss_scan_btn').click(function(){
					console.log('Initiating Scan');
					mss_start_scan = {
						mss_start_scan_nonce: '<?php echo wp_create_nonce( 'mss_start_scan' ); ?>',
						action: "mss_start_scan",
					};
					$.ajax({
						url: ajaxurl,
						method: 'POST',
						data: mss_start_scan,
						success: function(data, textStatus, jqXHR) {
							console.dir('success Data Begins');
							console.dir(data);
							console.dir(textStatus);
							console.dir(jqXHR);
							console.dir('success Data Ends');
							mss_status_updater = setTimeout(mss_update_scan_status,1000);
						},
						error: function( jqXHR, textStatus, errorThrown){},
						complete: function(jqXHR_data, textStatus) {
							console.log('This page needs to reload to watch progress.')
							// location.reload();
						},
					});
				});
			});
		</script>
		<?php
	}

	public function start_scanning() {
		$this->flog( __FUNCTION__ );
		$this->resume_state();
		if ( $this->state ) {
			$this->flog( 'Found previous state.' );
			$this->flog( $this->flog( $this->state ) );
			$this->resume_indexing();
		} else {
			$this->state = array(
				// 'indexing'          => true,
				'indexed_files'      => array(),
				'stack'              => array(
					'/_extvol_data/html/dev/plugindev/wp/scan' => array( 'counter' => 0 ),
				),
				'current_directory'  => '/_extvol_data/html/dev/plugindev/wp/scan',
				'previous_directory' => '/_extvol_data/html/dev/plugindev/wp/scan',
			);
			// $this->flog( $this->state );
			// return;
			$this->index_files_recursively();
		}

		$this->flog( 'Final state before clearing' );
		$this->flog( $this->state );
		$this->clear_state();
		// Save the indexed files to the database or perform any other required operations
		// $this->save_indexed_files();
	}

	private function save_state() {
		$this->flog( __FUNCTION__ );
		$file_path = trailingslashit( __DIR__ ) . 'state.txt'; // Replace with the desired file path
		file_put_contents( $file_path, serialize( $this->state ) );
	}

	private function clear_state() {
		$this->flog( __FUNCTION__ );
		$file_path = trailingslashit( __DIR__ ) . 'state.txt'; // Replace with the desired file path
		file_put_contents( $file_path, '' );
	}

	private function resume_state() {
		$this->flog( __FUNCTION__ );
		$file_path = trailingslashit( __DIR__ ) . 'state.txt'; // Replace with the desired file path
		if ( file_exists( $file_path ) ) {
			$data = file_get_contents( $file_path );
			$data = unserialize( $data );
			if ( $data && is_array( $data ) ) {
				$data = array_filter( $data );
				if ( ! empty( $data ) ) {
					$this->state = $data;
				}
			}
		}
	}

	function resume_indexing() {
		$this->flog( __FUNCTION__ );
		// $this->resume_state();
		$this->index_files_recursively();
	}

	public function index_files_recursively() {
		$this->flog( str_repeat( "\t\t\t", $this->pad ) );
		$this->flog( str_repeat( "\t\t\t", $this->pad ) . __FUNCTION__ . ' to scan ' . $this->state['current_directory'] );
		if ( $this->valid_dir( $this->state['current_directory'] ) ) {
			$entries = scandir( $this->state['current_directory'] );
			$entries = array_diff( $entries, array( '.', '..' ) );
			natcasesort( $entries ); // sort case insensitive "natural order" algorithm
			$entries = array_values( $entries ); // reset indices so that they start with 0
			// if ( $entries !== false ) { // if the directory is not empty
			$this->flog( str_repeat( "\t\t\t", $this->pad ) . '$entries inside ' . $this->state['current_directory'] . ' are:' );
			// $this->flog( str_repeat( "\t\t\t", $this->pad ) . implode( ',', $entries ) );
			$this->flog( str_repeat( "\t\t\t", $this->pad ) . json_encode( $entries, JSON_FORCE_OBJECT ) );
			$this->flog( str_repeat( "\t\t\t", $this->pad ) . 'counter for current directory:' . $this->state['current_directory'] . ' is ' . $this->state['stack'][ $this->state['current_directory'] ]['counter'] );
			// $this->state['stack'][ $this->state['current_directory'] ]['counter'] );
			for ( $i = $this->state['stack'][ $this->state['current_directory'] ]['counter']; $i < count( $entries ); $i++ ) {
				// $this->maybe_fork_via_ajax();
				$full_path = trailingslashit( $this->state['current_directory'] ) . $entries[ $this->state['stack'][ $this->state['current_directory'] ]['counter'] ];
				$this->state['stack'][ $this->state['current_directory'] ]['counter']++;

				$type = is_dir( $full_path ) ? 'dir' : 'file';
				$this->flog( str_repeat( "\t\t\t", $this->pad ) . '$i=' . $i . ' for:' . $this->state['current_directory'] . ' points to:' . $entries[ $i ] . ' Type: ' . $type . ' Full_path:' . $full_path );
				if ( $this->valid_file( $full_path ) ) {
					$this->state['indexed_files'][] = $full_path;
					$this->flog( str_repeat( "\t\t\t", $this->pad ) . 'INDEXED FILE:' . $full_path );
				} elseif ( $this->valid_dir( $full_path ) ) {
					$this->pad++;
					$this->state['previous_directory']  = $this->state['current_directory']; // Set the current directory
					$this->state['current_directory']   = $full_path; // Set the current directory
					$this->state['stack'][ $full_path ] = array( 'counter' => 0 ); // Add the directory to the stack
					$this->flog( str_repeat( "\t\t\t", $this->pad ) . 'FOUND DIRECTORY. Starting iterating inside:' . $full_path );
					$this->index_files_recursively();
					$this->pad--;
					$this->flog( str_repeat( "\t\t\t", $this->pad ) . 'RESUMED. ' . $this->state['previous_directory'] );
					$this->state['current_directory'] = $this->state['previous_directory']; // Set the current directory
					// $this->state['stack'][$this->state['previous_directory']]['counter']++; // chatgpt
				}
			}
			// } else {
				// Handle the error if scandir fails
			// $this->flog( 'No elements inside ' .$this->state['current_directory'] );
			// }
		}

	}

	public function maybe_fork_via_ajax() {
		$max_execution_time = ini_get( 'max_execution_time' ); // Get the max_execution_time
		$elapsed            = time() - ( $_SERVER['REQUEST_TIME'] );
		$remaining_time     = ( $max_execution_time - $elapsed );
		// + $max_execution_time ); // start time + max time
		if ( $remaining_time <= 2 ) {
			$this->flog( __FUNCTION__ );
			// If there are 2 seconds or less remaining, save the data and exit

			$this->save_state();
			$fork = wp_remote_get(
				admin_url( 'admin-ajax.php?action=mss_start_scan' ),
				array(
					'timeout'  => 0.01,
					'blocking' => false,
				)
			);
			$this->flog( 'Exiting because of remaining_time:' . $remaining_time );
			error_log( 'Exiting because of remaining_time:' . $remaining_time );
			exit;
		} else {
			$this->flog( 'Time has not arrived. remaining_time:' . $remaining_time . ' max_execution_time:' . $max_execution_time );
		}
	}

	function valid_dir( $dir ) {
		if ( is_dir( $dir ) && ! is_link( $dir ) && ! preg_match( '/\.git\b/', $dir ) ) {
			return true;
		}
	}

	function valid_file( $file ) {
		if ( is_file( $file ) && ! is_link( $file ) && filesize( $file ) && filesize( $file ) < $this->filemaxsize ) {
			return true;
		}
	}

	function is_cli() {
		return defined( 'WP_CLI' ) && WP_CLI;
	}

	function get_dump( $obj ) {
		ob_start();
		var_dump( $obj );
		$result = ob_get_clean();
		return $result;
	}

	function flog( $str ) {
		if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
			$date = date( 'Ymd-G:i:s' ); // 20171231-23:59:59
			$date = $date . '-' . microtime( true );

			$file = '/var/www/html/dev/plugindev/wp/wp-content/plugins/malcure-security-suite/log.log';

			$str = print_r( $str, true );
			if ( ! $this->is_cli() ) {
				file_put_contents( $file, $str . PHP_EOL, FILE_APPEND | LOCK_EX );
			} else {
				WP_CLI::log( $str );
			}
		}
	}
}

Malcure_Malware_Scanner::get_instance();
