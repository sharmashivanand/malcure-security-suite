<?php
/*
Summary of the `Malcure_Malware_Scanner` class:

The `Malcure_Malware_Scanner` class is a singleton class designed to perform file scanning and indexing in WordPress for detecting malware. It provides methods to recursively scan all files within the WordPress installation directory (ABSPATH), identifying potential malware-infected files based on certain criteria. The class is designed to handle large file systems efficiently and can resume scanning from where it left off in case of interruptions like reaching the maximum execution time.

Key Features:

1. Singleton Pattern: The class follows the singleton design pattern, ensuring that only one instance of the `Malcure_Malware_Scanner` class exists throughout the WordPress runtime. This is achieved through a static `$instance` variable and a private constructor.

2. Max Execution Time: The class sets a maximum execution time of 5 seconds for each scan to prevent long-running processes that may cause server resource issues.

3. AJAX Interface: The class integrates with WordPress AJAX functionality, allowing users to initiate the malware scan from the admin area with the click of a button. The scan progress is displayed to the user asynchronously.

4. File Indexing: The class recursively indexes all files within the WordPress installation directory (ABSPATH) by collecting their absolute paths in the `$file_paths` property. It filters files based on certain criteria such as valid directories, non-symlink files, and files below a certain size (specified by the `$filemaxsize` property).

5. Resume Scanning: The class supports the ability to resume scanning from where it left off in case of interruptions. The scanning progress is saved before the script shuts down (e.g., due to reaching the max execution time), and it can be retrieved and continued when the scanning process is initiated again.

6. Meta Boxes: The class adds a meta box labeled "Malware Scanner" to the WordPress admin interface, where users can start the scanning process.

7. Saving Indexed Files: After completing the scanning process, the class saves the indexed file paths (stored in the `$file_paths` property) to the WordPress database or performs any other desired operations.

8. Logging: The class utilizes a function `flog` to log messages, aiding in debugging and monitoring the scanning process.

How it Works:

1. Initialization: The class is initialized as a singleton using the `get_instance()` method, which ensures that only one instance of the class is created.

2. AJAX Integration: The class sets up AJAX actions to handle the initiation of the scanning process from the WordPress admin area.

3. Scanning Process: The `start_scanning()` method is called when the malware scan is triggered. This method handles the entire scanning process.

4. File Indexing: The scanning process begins by recursively indexing all valid files within the WordPress installation directory (ABSPATH) and stores their absolute paths in the `$file_paths` property.

5. Resume Scanning: If the scanning process is interrupted (e.g., due to reaching the maximum execution time), the class saves the current state of the scanning process (indexed files) before shutting down. This state can be retrieved and used to continue scanning from where it left off.

6. AJAX Feedback: The scanning process initiates an AJAX call, providing progress feedback to the user. The progress can be monitored asynchronously through the admin interface.

7. Saving Indexed Files: Once the entire scan is complete, the class saves the indexed file paths to the WordPress database or performs any other required operations.

8. Logging: The class uses the `flog` function to log messages, which assists in debugging and monitoring the scanning process.

In summary, the `Malcure_Malware_Scanner` class is an effective and efficient solution for scanning WordPress installations for malware. It provides a secure and user-friendly way to identify potential security threats and take appropriate actions to safeguard the website from malicious code.
*/


if ( ! defined( 'ABSPATH' ) ) {
	exit;
}

/**
 * Singleton Class for WordPress File Indexer
 */
final class Malcure_Malware_Scanner {
	private static $instance = null;

	private $indexing   = false;
	private $file_paths = array();
	private $current_directory;
	private $msu;
	public $filemaxsize = 1111111;

	private function __construct() {
		// register_shutdown_function( array( $this, 'maybe_save_and_fork_via_ajax' ) );
	}

	public static function get_instance() {
		if ( self::$instance === null ) {
			self::$instance = new self();
			self::$instance->init();
		}
		return self::$instance;
	}

	function init() {
		if ( defined( 'WP_CLI' ) && WP_CLI ) {
			ini_set( 'max_execution_time', 5 );
		}
		add_action( 'Malcure_security_suite_add_meta_boxes', array( $this, 'add_meta_boxes' ), 8 );
		add_action( 'wp_ajax_nopriv_mss_start_scan', array( $this, 'start_scanning' ) );
		add_action( 'wp_ajax_mss_start_scan', array( $this, 'start_scanning' ) );
	}


	function add_meta_boxes() {

		add_meta_box( 'mss_scanner', 'Malware Scanner', array( $this, 'scanner_meta_box' ), $GLOBALS['Malcure_security_suite']['pagehook'], 'main' );
	}

	function scanner_meta_box() {

		echo '<input class="mss_action" value="Click" id="mss_scan_btn" type="submit" />';
		echo '<pre>' . print_r( get_option( 'file_indexed_files' ), 1 ) . '</pre>';
		?>
		<script type="text/javascript">
			jQuery(document).ready(function($){
				$('#mss_scan_btn').click(function(){
					console.log('Initiating Scan');
					mss_start_scan = {
						mss_start_scan_nonce: '<?php echo wp_create_nonce( 'mss_start_scan' ); ?>',
						action: "mss_start_scan",
					};
					$.ajax({
						url: ajaxurl,
						method: 'POST',
						data: mss_start_scan,
						success: function(data, textStatus, jqXHR) {
							console.dir('success Data Begins');
							console.dir(data);
							console.dir(textStatus);
							console.dir(jqXHR);
							console.dir('success Data Ends');
							mss_status_updater = setTimeout(mss_update_scan_status,1000);
						},
						error: function( jqXHR, textStatus, errorThrown){},
						complete: function(jqXHR_data, textStatus) {
							console.log('This page needs to reload to watch progress.')
							// location.reload();
						},
					});
				});
			});
		</script>
		<?php
	}

	function is_cli() {
		return defined( 'WP_CLI' ) && WP_CLI;
	}

	public function start_scanning() {
		$this->flog( __FUNCTION__ . ' called' );
		if ( $this->indexing ) {
			$this->flog( 'Indexing already in progress' );
			return; // Already indexing, don't start again
		}

		$this->indexing          = true;
		$this->file_paths        = array();
		$this->current_directory = ABSPATH;

		$previous_state = $this->get_indexing_state();
		if ( $previous_state ) {
			$this->flog( 'Found previous state.' );
			$this->resume_indexing( $previous_state );
		} else {
			$this->index_files_recursively( $this->current_directory );
		}

		$this->indexing = false;
		$this->save_indexing_state( null ); // Clear the state after completion

		// Save the indexed files to the database or perform any other required operations
		$this->save_indexed_files();
	}

	function valid_dir( $dir ) {
		if ( is_dir( $dir ) && ! is_link( $dir ) ) {
			return true;
		}
	}

	function valid_file( $file ) {
		if ( is_file( $file ) && ! is_link( $file ) && filesize( $file ) && filesize( $file ) < $this->filemaxsize ) {
			return true;
		}
	}

	public function index_files_recursively( $path ) {

		$this->current_directory = $path;
		$this->flog( 'Indexing dir: ' . $path );

		$file_paths = array();
		if ( $this->valid_dir( $path ) ) {
			$entries = scandir( $path );
			if ( $entries !== false ) {
				foreach ( $entries as $entry ) {
					if ( $entry !== '.' && $entry !== '..' ) {
						$full_path = trailingslashit( $path ) . $entry;
						if ( $this->valid_file( $full_path ) ) {
							$this->flog( 'Indexing file: ' . $full_path );
							$this->file_paths[] = $full_path;
						} elseif ( $this->valid_dir( $full_path ) ) {
							$this->index_files_recursively( $full_path );
						}
					}
					$this->maybe_save_and_fork_via_ajax();
				}
			} else {
				// Handle the error if scandir fails
				error_log( "Error scanning directory '{$path}'" );
			}
		}
		return $file_paths;
	}

	function flog( $str ) {
		if ( defined( 'WP_DEBUG' ) && WP_DEBUG ) {
			$date = date( 'Ymd-G:i:s' ); // 20171231-23:59:59
			$date = $date . '-' . microtime( true );

			$file = '/var/www/html/dev/plugindev/wp/wp-content/plugins/malcure-security-suite/log.log';

			$str = print_r( $str, true );
			if ( ! $this->is_cli() ) {
				file_put_contents( $file, $str . PHP_EOL, FILE_APPEND | LOCK_EX );
			} else {
				WP_CLI::log( $str );
			}
		}
	}

	public function get_file_paths() {
		return $this->file_paths;
	}

	public function serialize() {
		return serialize(
			array(
				'file_paths'        => $this->file_paths,
				'current_directory' => $this->current_directory,
			)
		);
	}

	public function unserialize( $serialized ) {
		$data = unserialize( $serialized );
		$this->flog( __FUNCTION__ );
		$this->flog( $this->current_directory );
		if ( is_array( $data ) ) {
			$this->file_paths        = $data['file_paths'];
			$this->current_directory = $data['current_directory'];
			// Restore any other properties here
		}
	}



	private function get_indexing_state() {
		$file_path = trailingslashit( __DIR__ ) . 'data.txt'; // Replace with the desired file path
		if ( file_exists( $file_path ) ) {
			$data = file_get_contents( $file_path );
			return $data;
		}
		return null;
	}

	private function resume_indexing( $previous_state ) {
		$this->unserialize( $previous_state );

		$current_indexed_files = $this->get_file_paths();

		// Get the current directory
		$current_dir = $this->current_directory;

		// Get the directories already indexed
		$indexed_dirs = array_map( 'dirname', $current_indexed_files );
		$indexed_dirs = array_unique( $indexed_dirs );

		// Get the directories that still need to be indexed
		$directories_to_index = array_diff( scandir( $current_dir ), array( '.', '..' ) );
		$this->flog( 'directories_to_index: ' . count( $directories_to_index ) );
		$directories_to_index = array_filter( $directories_to_index, array( $this, 'valid_dir' ) );
		$directories_to_index = array_map(
			function( $dir ) use ( $current_dir ) {
				return trailingslashit( $current_dir ) . $dir;
			},
			$directories_to_index
		);
		$directories_to_index = array_diff( $directories_to_index, $indexed_dirs );

		// Now continue indexing from the directories that still need to be indexed
		foreach ( $directories_to_index as $dir ) {
			$this->flog( 'Resuming indexing dir: ' . $dir );
			$this->index_files_recursively( $dir );
		}
	}

	public function maybe_save_and_fork_via_ajax() {
		$max_execution_time = ini_get( 'max_execution_time' ); // Get the max_execution_time
		$remaining_time     = $_SERVER['REQUEST_TIME'] + $max_execution_time - time();
		if ( $remaining_time <= 2 ) {
			// If there are 2 seconds or less remaining, save the data
			$state_data = $this->serialize();
			$this->save_indexing_state( $state_data );
			$this->flog( '' );
			$this->flog( 'Forking because of remaining_time:' . $remaining_time . ' current dir: ' . $this->current_directory );
			// $this->flog( $state_data );
			$this->flog( '' );
			wp_remote_get(
				admin_url( 'admin-ajax.php?action=mss_start_scan' ),
				array(
					'timeout'  => 0.01,
					'blocking' => false,
				)
			);
			exit;
		}
	}

	private function save_indexing_state( $state_data ) {
		$file_path = trailingslashit( __DIR__ ) . 'data.txt'; // Replace with the desired file path
		file_put_contents( $file_path, $state_data );
	}

	private function save_indexed_files() {
		// Implement the logic to save indexed files to the database or perform other operations.
		// For example, you can use update_option( 'file_indexed_files', $this->file_paths ) to save the data as an option in the WordPress database.
	}
}

Malcure_Malware_Scanner::get_instance();
